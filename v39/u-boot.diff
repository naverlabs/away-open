diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/Makefile lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/Makefile
--- repo_avn/linux/bootloader/u-boot-2014.07/Makefile	2017-07-12 22:08:15.592987144 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/Makefile	2017-02-27 22:07:51.777874000 +0900
@@ -524,6 +524,11 @@
 KBUILD_CFLAGS += -DBUILD_TAG='"$(BUILD_TAG)"'
 endif
 
+ifneq ($(BOOTARGS),)
+KBUILD_CFLAGS += -DCONFIG_EMMC_SERIALNO
+KBUILD_CFLAGS += -DCONFIG_BOOTARGS='"$(BOOTARGS)"'
+endif
+
 KBUILD_CFLAGS += $(call cc-option,-fno-stack-protector)
 
 KBUILD_CFLAGS	+= -g
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/README_s5p6818_navi lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/README_s5p6818_navi
--- repo_avn/linux/bootloader/u-boot-2014.07/README_s5p6818_navi	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/README_s5p6818_navi	2017-07-11 11:08:23.866610000 +0900
@@ -0,0 +1,4 @@
+make distclean
+ROOT_DEVICE_TYPE=sd
+make s5p6818_navi_config
+make -j8  
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd.c
--- repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd.c	2017-07-12 22:08:15.612987135 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd.c	2017-02-27 22:07:51.777874000 +0900
@@ -34,6 +34,11 @@
 #include <mach-types.h>
 #include <mach-api.h>
 
+#if defined(CONFIG_EMMC_SERIALNO)
+#include <mmc.h>
+extern struct mmc *g_init_mmc;
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_SETUP_MEMORY_TAGS) || \
@@ -86,6 +91,17 @@
 {
 	char *p;
 
+#if defined(CONFIG_EMMC_SERIALNO)
+    const char *serialno_prop = "androidboot.serialno";
+    char commandline_data[512];
+
+#if defined(CONFIG_BOOTARGS)
+    if(!commandline){
+        commandline = CONFIG_BOOTARGS;
+    }
+#endif
+#endif
+
 	if (!commandline)
 		return;
 
@@ -98,6 +114,22 @@
 	if (*p == '\0')
 		return;
 
+#if defined(CONFIG_EMMC_SERIALNO)
+    if(!(strstr(p, serialno_prop))){
+        puts("adding serialno\n");
+        if(g_init_mmc){
+            puts("ok mmc\n");
+            memset(commandline_data, 0x00, 512);
+            sprintf(commandline_data, "%s %s=%x%x%x%x%x", p, serialno_prop, (g_init_mmc->cid[2] >> 8) & 0xff, (g_init_mmc->cid[2] & 0xff), (g_init_mmc->cid[3] >> 24) & 0xff, (g_init_mmc->cid[3] >> 16) & 0xff, (g_init_mmc->cid[3] >> 8) & 0xff);
+            printf("%s\n", commandline_data);
+            p = commandline_data;
+        }else{
+            puts("NO MMC device\n");
+            return;
+        }
+    }
+#endif
+
 	params->hdr.tag = ATAG_CMDLINE;
 	params->hdr.size =
 		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd_fastboot.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd_fastboot.c
--- repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd_fastboot.c	2017-07-12 22:08:15.616987135 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/common/cmd_fastboot.c	2017-03-04 23:07:45.383440000 +0900
@@ -1859,6 +1859,7 @@
 
 		sort_string((char*)p, strlen(p));
 		setenv("fastboot", (char *)p);
+        setenv("bootcmd", "ext4load mmc 2:6 0x40008000 Image;ext4load mmc 2:6 0x49000000 ramdisk-recovery.img;goimage 0x40008000");  // SDY
 		saveenv();
 	}
 
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/devices/i2c_gpio.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/devices/i2c_gpio.c
--- repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/devices/i2c_gpio.c	2017-07-12 22:08:15.620987133 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/devices/i2c_gpio.c	2017-02-10 15:49:03.640648000 +0900
@@ -55,8 +55,9 @@
  */
 #define	I2C_DELAY_HZ		100000
 
-#define	_SHT_		(1)		/* start  hold  time */
-#define	_EST_		(1)		/* Stop   setup time */
+#define	_SST_		(4)		/* start  setup  time */
+#define	_SHT_		(4)		/* start  hold  time */
+#define	_EST_		(4)		/* Stop   setup time */
 #define	_DHT_		(1)		/* data   hold  time */
 #define	_DST_		(1)		/* data   setup time */
 #define	_CHT_		(1)		/* clock  hold  time */
@@ -75,11 +76,12 @@
 
 	/* SCL/SDA High */
 	I2C_SDA_H(sda);
-	I2C_DELAY(1, d);
+	I2C_DELAY(_SST_, d);
 
 	/* START signal */
 	I2C_SCL_H(scl);
-	I2C_DELAY(1, d);
+//	I2C_DELAY(1, d);
+	I2C_DELAY(_SHT_, d);
 	I2C_SDA_L(sda);
 	I2C_DELAY(_SHT_, d);	/* Start hold */
 
@@ -98,7 +100,7 @@
 	I2C_SCL_H(scl);
 	I2C_DELAY(_EST_, d);
 	I2C_SDA_H(sda);
-	I2C_DELAY(1, d);
+	I2C_DELAY(_EST_, d);
 
 	I2C_SCL_I(scl);
 	I2C_SDA_I(sda);
@@ -109,8 +111,9 @@
 	int scl = i2c->scl, sda = i2c->sda;
 	int d = i2c->delay;
 	int i, nack = 0;
+	int scl_stretch_cnt;
 
-	I2C_SDA_H(sda);
+//	I2C_SDA_H(sda);
 
 	for (i=7 ; i >= 0 ; i--) {
 		if (data & (1<<i))
@@ -119,7 +122,15 @@
 			I2C_SDA_L(sda);
 
 		I2C_DELAY(_DST_, d);
-		I2C_SCL_H(scl);
+		I2C_SCL_I(scl);
+		I2C_DELAY(_CHT_, d);
+		for(scl_stretch_cnt = 20; scl_stretch_cnt; scl_stretch_cnt--)
+		{
+			if(I2C_SCL_R(scl) != 0)
+				break;
+
+			I2C_DELAY(_CHT_, d);
+		}
 		I2C_DELAY(_CHT_, d);
 		I2C_SCL_L(scl);
 		I2C_DELAY(_DHT_, d);
@@ -127,14 +138,27 @@
 
 	I2C_SDA_I(sda);
 	I2C_DELAY(_DST_, d);
-	I2C_SCL_H(scl);
+	I2C_DELAY(_CHT_*3, d);
+	I2C_SCL_I(scl);	/* instead of high */
 	I2C_DELAY(_CHT_, d);
 
+	for(scl_stretch_cnt = 20; scl_stretch_cnt;scl_stretch_cnt--)
+	{
+		if(I2C_SCL_R(scl) != 0)
+			break;
+
+		I2C_DELAY(_CHT_, d);
+	}
+	if(scl_stretch_cnt == 0) {
+		printf("i2c.write_byte : scl timeout\n");
+		return -1;
+	}
+
 	nack = I2C_SDA_R(sda);
 
 	I2C_SCL_L(scl);
 	I2C_DELAY(_DHT_, d);
-	I2C_SDA_I(sda);	/* END */
+//	I2C_SDA_I(sda);	/* END */
 
 	return (nack ? -1 : 0);
 }
@@ -145,13 +169,22 @@
 	int d = i2c->delay;
 	uchar data = 0;
 	int i;
+	int scl_stretch_cnt = 20;
 
 	I2C_SDA_I(sda);
 
 	for (i=7; i >= 0; i--) {
 		I2C_DELAY(_DST_, d);
-		I2C_SCL_H(scl);
+//		I2C_SCL_H(scl);
+		I2C_SCL_I(scl);
 		I2C_DELAY(_CHT_, d);
+		for(scl_stretch_cnt = 20; scl_stretch_cnt; scl_stretch_cnt--)
+		{
+			if(I2C_SCL_R(scl) != 0)
+				break;
+
+			I2C_DELAY(_CHT_, d);
+		}
 
 		/* Falling Edge */
 		if (I2C_SDA_R(sda))
@@ -159,6 +192,7 @@
 		else
 			data = (unsigned char)(data | (0<<i));
 
+		I2C_DELAY(_CHT_, d);
 		I2C_SCL_L(scl);
 		I2C_DELAY(_DHT_, d);
 	}
@@ -170,7 +204,8 @@
 		I2C_SDA_H(sda);
 
 	I2C_DELAY(_DST_, d);
-	I2C_SCL_H(scl);
+//	I2C_SCL_H(scl);
+	I2C_SCL_I(scl);
 	I2C_DELAY(_CHT_, d);
 	I2C_SCL_L(scl);
 	I2C_DELAY(_DHT_, d);
@@ -219,7 +254,7 @@
 	data = chip;
 	ret  = write_byte(i2c, data);
 	if (ret) {
-		printf("Fail, i2c.%d start wait ack, addr:0x%02x \n", i2c->bus, data);
+		printf("Fail, i2c.%d start wait ack when write, addr:0x%02x \n", i2c->bus, data);
 		goto exit_w;
 	}
 
@@ -275,7 +310,7 @@
 	data = (chip<<1) | 0x01;
 	ret  = write_byte(i2c, data);
 	if (ret) {
-		printf("Fail, i2c.%d start wait ack, addr:0x%02x \n", i2c->bus, data);
+		printf("Fail, i2c.%d start wait ack when read, addr:0x%02x \n", i2c->bus, data);
 		goto exit_r;
 	}
 
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/device.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/device.c
--- repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/device.c	2017-07-12 22:08:15.628987130 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/device.c	2017-02-10 15:49:03.640648000 +0900
@@ -159,6 +159,7 @@
     { .bus = 8, .scl = I2C8_SCL, .sda = I2C8_SDA, .speed = CONFIG_SYS_I2C_SPEED, .nostop = CONFIG_I2C8_NO_STOP, },
 #endif
 
+
 };
 
 int i2c_gpio_init(int bus)
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/reset.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/reset.c
--- repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/reset.c	2017-07-12 22:08:15.628987130 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/s5p6818/reset.c	2017-02-20 22:14:03.715024000 +0900
@@ -22,9 +22,21 @@
  */
 #include <common.h>
 #include <platform.h>
+#ifdef CONFIG_MACH_S5P6818_NAVI
+#include <i2c.h>
+#endif
 
 void reset_cpu(ulong ignored)
 {
+#ifdef CONFIG_MACH_S5P6818_NAVI
+#define AVR_I2C_ADDR 0x63
+#define AVR_RESET_TIMER_ADDR 0xF
+	char buf[2];
+
+        I2C_SET_BUS(8);
+	buf[0] = 10;
+	i2c_write(AVR_I2C_ADDR, AVR_RESET_TIMER_ADDR, 1, buf, 1);
+#endif
 	/* Software reset */
 	NX_CLKPWR_SetSoftwareResetEnable(CTRUE);
 	NX_CLKPWR_DoSoftwareReset();
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/include/asm/arch-s5p6818/pm.h lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/include/asm/arch-s5p6818/pm.h
--- repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/include/asm/arch-s5p6818/pm.h	2017-07-12 22:08:15.644987124 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/include/asm/arch-s5p6818/pm.h	2017-03-06 21:36:58.777834000 +0900
@@ -60,8 +60,8 @@
 #define	SUSPEND_SAVE_SIZE		(128*1024)		/* (_etext - _stext) */
 #define RECOVERY_SIGNATURE		(0x52455343)	/* (ASCII) : R.E.S.C */
 #define UPDATE_SIGNATURE        (0x55444154)    /* (ASCII) : U.D.A.T */
-
-
+#define FASTBOOT_SIGNATURE		(0x46415354)	/* (ASCII) : F.A.S.T */
+#define USBBOOT_SIGNATURE		(0x85836666)	/* (ASCII) : U.S.B.B */
 #define	SCR_SMP_WAKE_CPU_ID		SCR_ARM_SECOND_BOOT_REG1
 #define	SCR_SMP_SIG_RESET		SCR_USER_SIG6_RESET
 #define	SCR_SMP_SIG_SET			SCR_USER_SIG6_SET
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/lib/bootm.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/lib/bootm.c
--- repo_avn/linux/bootloader/u-boot-2014.07/arch/arm/lib/bootm.c	2017-07-12 22:08:15.648987121 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/arch/arm/lib/bootm.c	2017-02-27 22:07:51.777874000 +0900
@@ -22,6 +22,11 @@
 #include <asm/bootm.h>
 #include <linux/compiler.h>
 
+#if defined(CONFIG_EMMC_SERIALNO)
+#include <mmc.h>
+extern struct mmc *g_init_mmc;
+#endif
+
 #if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
 #include <asm/armv7.h>
 #endif
@@ -116,6 +121,18 @@
 {
 	char *p;
 
+#if defined(CONFIG_EMMC_SERIALNO)
+    const char *serialno_prop = "androidboot.serialno";
+    char commandline_data[512];
+
+#if defined(CONFIG_BOOTARGS)
+    struct mmc *mmc;
+    if(!commandline){
+        commandline = CONFIG_BOOTARGS;
+    }
+#endif
+#endif
+
 	if (!commandline)
 		return;
 
@@ -128,6 +145,22 @@
 	if (*p == '\0')
 		return;
 
+#if defined(CONFIG_EMMC_SERIALNO)
+    if(!(strstr(p, serialno_prop))){
+		puts("adding serialno\n");
+        if(g_init_mmc){
+            puts("ok mmc\n");
+            memset(commandline_data, 0x00, 512);
+            sprintf(commandline_data, "%s %s=%x%x%x%x%x", p, serialno_prop, (mmc->cid[2] >> 8) & 0xff, (mmc->cid[2] & 0xff), (mmc->cid[3] >> 24) & 0xff, (mmc->cid[3] >> 16) & 0xff, (mmc->cid[3] >> 8) & 0xff);
+            printf("%s\n", commandline_data);
+            p = commandline_data;
+        }else{
+            puts("NO MMC device\n");
+            return;
+        }
+    }
+#endif
+
 	params->hdr.tag = ATAG_CMDLINE;
 	params->hdr.size =
 		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/Makefile lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/Makefile
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/Makefile	2017-01-24 18:43:35.365467000 +0900
@@ -0,0 +1,3 @@
+
+obj-y	:= board.o
+obj-$(CONFIG_DISPLAY_OUT)	+= display.o fastboot_lcd.o
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/board.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/board.c
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/board.c	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/board.c	2017-05-01 15:06:59.053462000 +0900
@@ -0,0 +1,607 @@
+/*
+ * (C) Copyright 2009
+ * jung hyun kim, Nexell Co, <jhkim@nexell.co.kr>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <pwm.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+//#include <asm/sections.h>
+
+#include <platform.h>
+#include <mach-api.h>
+#include <rtc_nxp.h>
+#include <pm.h>
+
+#include <draw_lcd.h>
+#include <linux/time.h>
+
+#if defined(CONFIG_PMIC)
+#include <power/pmic.h>
+#endif
+
+#if defined(CONFIG_PMIC_NXE2000)
+#include <nxe2000-private.h>
+#endif
+
+#if defined (CONFIG_USB_HUB_USB2514)
+#include <usb2514.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#include "eth.c"
+
+#if (0)
+#define DBGOUT(msg...)		{ printf("BD: " msg); }
+#else
+#define DBGOUT(msg...)		do {} while (0)
+#endif
+
+#define BOOT_OPTION_RECOVERY 0x01
+#define BOOT_OPTION_UPDATE 0x02
+#define BOOT_OPTION_USBBOOT 0xDD
+#define BOOT_OPTION_FASTBOOT 0x04
+
+#define BOOT_OPTION_ADDR 1
+#define REBOOT_TIMER_ADDR 0xF
+
+#define KEY_CODE_UNKNOW		 	0 
+#define KEY_CODE_POWER_SHORT 	1
+#define KEY_CODE_POWER_LONG 	2
+
+#define KEY_STAT_NULL 	  		0
+#define KEY_STAT_PRESSED  		1
+#define KEY_STAT_RELEASED 		2
+
+#define STATUS_NOMAL_MODE 		0
+#define STAUTS_RECOVERY_MODE	1
+#define STATUS_USB_DOWN_MODE	2
+#define STATUS_FASTBOOT_MODE	3 // joon  -- change boot menu
+
+
+#define AVR_I2C_ADDR 0x63
+#define AVR_BOOT_OPTION_ADDR 0x1
+#define AVR_VERSION_ADDR_FIRST 0x2
+#define AVR_VERSION_ADDR_SECOND 0x3
+#define AVR_RESET_INFO_ADDR 0x4
+#define AVR_WDT_CTRL_MAGIC_ADDR 0x5
+#define AVR_WDT_COUNTER_ADDR 0x7
+#define AVR_KEY_STATUS_ADDR 0x8
+#define AVR_KEY_CODE_ADDR 0x9
+
+#define AVR_RECOVERY_ADDR 0xBC      // SDY -- ota update
+#define AVR_RECOVERY2_ADDR  0xBE    // SDY -- ota update
+#define AVR_RECOVERY_IMG_ADDR 0xBF  // SDY -- ota update
+
+
+#define AVR_REBOOT_TIMER_ADDR 0xF
+#define AVR_RESET_LONG_POWERKEY 0x3
+
+static int recovery_mode = 0;   // SDY -- ota update
+
+#define WATCHDOG_TIMEOUT	10	// seconds
+/*------------------------------------------------------------------------------
+ * intialize nexell soc and board status.
+ */
+
+static void bd_gpio_init(void)
+{
+	int index, bit;
+	int mode, func, out, lv, plup, stren;
+	U32 gpio;
+
+	const U32 pads[NUMBER_OF_GPIO_MODULE][32] = {
+	{	/* GPIO_A */
+	PAD_GPIOA0 , PAD_GPIOA1 , PAD_GPIOA2 , PAD_GPIOA3 , PAD_GPIOA4 , PAD_GPIOA5 , PAD_GPIOA6 , PAD_GPIOA7 , PAD_GPIOA8 , PAD_GPIOA9 ,
+	PAD_GPIOA10, PAD_GPIOA11, PAD_GPIOA12, PAD_GPIOA13, PAD_GPIOA14, PAD_GPIOA15, PAD_GPIOA16, PAD_GPIOA17, PAD_GPIOA18, PAD_GPIOA19,
+	PAD_GPIOA20, PAD_GPIOA21, PAD_GPIOA22, PAD_GPIOA23, PAD_GPIOA24, PAD_GPIOA25, PAD_GPIOA26, PAD_GPIOA27, PAD_GPIOA28, PAD_GPIOA29,
+	PAD_GPIOA30, PAD_GPIOA31
+	}, { /* GPIO_B */
+	PAD_GPIOB0 , PAD_GPIOB1 , PAD_GPIOB2 , PAD_GPIOB3 , PAD_GPIOB4 , PAD_GPIOB5 , PAD_GPIOB6 , PAD_GPIOB7 , PAD_GPIOB8 , PAD_GPIOB9 ,
+	PAD_GPIOB10, PAD_GPIOB11, PAD_GPIOB12, PAD_GPIOB13, PAD_GPIOB14, PAD_GPIOB15, PAD_GPIOB16, PAD_GPIOB17, PAD_GPIOB18, PAD_GPIOB19,
+	PAD_GPIOB20, PAD_GPIOB21, PAD_GPIOB22, PAD_GPIOB23, PAD_GPIOB24, PAD_GPIOB25, PAD_GPIOB26, PAD_GPIOB27, PAD_GPIOB28, PAD_GPIOB29,
+	PAD_GPIOB30, PAD_GPIOB31
+	}, { /* GPIO_C */
+	PAD_GPIOC0 , PAD_GPIOC1 , PAD_GPIOC2 , PAD_GPIOC3 , PAD_GPIOC4 , PAD_GPIOC5 , PAD_GPIOC6 , PAD_GPIOC7 , PAD_GPIOC8 , PAD_GPIOC9 ,
+	PAD_GPIOC10, PAD_GPIOC11, PAD_GPIOC12, PAD_GPIOC13, PAD_GPIOC14, PAD_GPIOC15, PAD_GPIOC16, PAD_GPIOC17, PAD_GPIOC18, PAD_GPIOC19,
+	PAD_GPIOC20, PAD_GPIOC21, PAD_GPIOC22, PAD_GPIOC23, PAD_GPIOC24, PAD_GPIOC25, PAD_GPIOC26, PAD_GPIOC27, PAD_GPIOC28, PAD_GPIOC29,
+	PAD_GPIOC30, PAD_GPIOC31
+	}, { /* GPIO_D */
+	PAD_GPIOD0 , PAD_GPIOD1 , PAD_GPIOD2 , PAD_GPIOD3 , PAD_GPIOD4 , PAD_GPIOD5 , PAD_GPIOD6 , PAD_GPIOD7 , PAD_GPIOD8 , PAD_GPIOD9 ,
+	PAD_GPIOD10, PAD_GPIOD11, PAD_GPIOD12, PAD_GPIOD13, PAD_GPIOD14, PAD_GPIOD15, PAD_GPIOD16, PAD_GPIOD17, PAD_GPIOD18, PAD_GPIOD19,
+	PAD_GPIOD20, PAD_GPIOD21, PAD_GPIOD22, PAD_GPIOD23, PAD_GPIOD24, PAD_GPIOD25, PAD_GPIOD26, PAD_GPIOD27, PAD_GPIOD28, PAD_GPIOD29,
+	PAD_GPIOD30, PAD_GPIOD31
+	}, { /* GPIO_E */
+	PAD_GPIOE0 , PAD_GPIOE1 , PAD_GPIOE2 , PAD_GPIOE3 , PAD_GPIOE4 , PAD_GPIOE5 , PAD_GPIOE6 , PAD_GPIOE7 , PAD_GPIOE8 , PAD_GPIOE9 ,
+	PAD_GPIOE10, PAD_GPIOE11, PAD_GPIOE12, PAD_GPIOE13, PAD_GPIOE14, PAD_GPIOE15, PAD_GPIOE16, PAD_GPIOE17, PAD_GPIOE18, PAD_GPIOE19,
+	PAD_GPIOE20, PAD_GPIOE21, PAD_GPIOE22, PAD_GPIOE23, PAD_GPIOE24, PAD_GPIOE25, PAD_GPIOE26, PAD_GPIOE27, PAD_GPIOE28, PAD_GPIOE29,
+	PAD_GPIOE30, PAD_GPIOE31
+	},
+	};
+
+	/* GPIO pad function */
+	for (index = 0; NUMBER_OF_GPIO_MODULE > index; index++) {
+
+		NX_GPIO_ClearInterruptPendingAll(index);
+
+		for (bit = 0; 32 > bit; bit++) {
+			gpio  = pads[index][bit];
+			func  = PAD_GET_FUNC(gpio);
+			mode  = PAD_GET_MODE(gpio);
+			lv    = PAD_GET_LEVEL(gpio);
+			stren = PAD_GET_STRENGTH(gpio);
+			plup  = PAD_GET_PULLUP(gpio);
+
+			/* get pad alternate function (0,1,2,4) */
+			switch (func) {
+			case PAD_GET_FUNC(PAD_FUNC_ALT0): func = NX_GPIO_PADFUNC_0;	break;
+			case PAD_GET_FUNC(PAD_FUNC_ALT1): func = NX_GPIO_PADFUNC_1;	break;
+			case PAD_GET_FUNC(PAD_FUNC_ALT2): func = NX_GPIO_PADFUNC_2;	break;
+			case PAD_GET_FUNC(PAD_FUNC_ALT3): func = NX_GPIO_PADFUNC_3;	break;
+			default: printf("ERROR, unknown alt func (%d.%02d=%d)\n", index, bit, func);
+				continue;
+			}
+
+			switch (mode) {
+			case PAD_GET_MODE(PAD_MODE_ALT): out = 0;
+			case PAD_GET_MODE(PAD_MODE_IN ): out = 0;
+			case PAD_GET_MODE(PAD_MODE_INT): out = 0; break;
+			case PAD_GET_MODE(PAD_MODE_OUT): out = 1; break;
+			default: printf("ERROR, unknown io mode (%d.%02d=%d)\n", index, bit, mode);
+				continue;
+			}
+
+			NX_GPIO_SetPadFunction(index, bit, func);
+			NX_GPIO_SetOutputEnable(index, bit, (out ? CTRUE : CFALSE));
+			NX_GPIO_SetOutputValue(index, bit,  (lv  ? CTRUE : CFALSE));
+			NX_GPIO_SetInterruptMode(index, bit, (lv));
+
+			NX_GPIO_SetPullEnable(index, bit, (NX_GPIO_PULL)plup );
+			NX_GPIO_SetDriveStrength(index, bit, (NX_GPIO_DRVSTRENGTH)stren); /* pad strength */
+		}
+	}
+}
+
+static void bd_alive_init(void)
+{
+	int index, bit;
+	int mode, out, lv, plup, detect;
+	U32 gpio;
+
+	const U32 pads[] = {
+	PAD_GPIOALV0, PAD_GPIOALV1, PAD_GPIOALV2,
+	PAD_GPIOALV3, PAD_GPIOALV4, PAD_GPIOALV5
+	};
+
+	index = sizeof(pads)/sizeof(pads[0]);
+
+	/* Alive pad function */
+	for (bit = 0; index > bit; bit++) {
+		NX_ALIVE_ClearInterruptPending(bit);
+		gpio = pads[bit];
+		mode = PAD_GET_MODE(gpio);
+		lv   = PAD_GET_LEVEL(gpio);
+		plup = PAD_GET_PULLUP(gpio);
+
+		switch (mode) {
+		case PAD_GET_MODE(PAD_MODE_IN ):
+		case PAD_GET_MODE(PAD_MODE_INT): out = 0; break;
+		case PAD_GET_MODE(PAD_MODE_OUT): out = 1; break;
+		case PAD_GET_MODE(PAD_MODE_ALT):
+			printf("ERROR, alive.%d not support alt function\n", bit);
+			continue;
+		default :
+			printf("ERROR, unknown alive mode (%d=%d)\n", bit, mode);
+			continue;
+		}
+
+		NX_ALIVE_SetOutputEnable(bit, (out ? CTRUE : CFALSE));
+		NX_ALIVE_SetOutputValue (bit, (lv));
+		NX_ALIVE_SetPullUpEnable(bit, (plup & 1 ? CTRUE : CFALSE));
+		/* set interrupt mode */
+		for (detect = 0; 6 > detect; detect++) {
+			if (mode == PAD_GET_MODE(PAD_MODE_INT))
+				NX_ALIVE_SetDetectMode(detect, bit, (lv == detect ? CTRUE : CFALSE));
+			else
+				NX_ALIVE_SetDetectMode(detect, bit, CFALSE);
+		}
+		NX_ALIVE_SetDetectEnable(bit, (mode == PAD_MODE_INT ? CTRUE : CFALSE));
+	}
+}
+
+/* call from u-boot */
+int board_early_init_f(void)
+{
+	bd_gpio_init();
+	bd_alive_init();
+#if (defined(CONFIG_PMIC_NXE2000)||defined(CONFIG_PMIC_AXP228))&& !defined(CONFIG_PMIC_REG_DUMP)
+	bd_pmic_init();
+#endif
+#if defined(CONFIG_NXP_RTC_USE)
+	nxp_rtc_init();
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	DBGOUT("%s : done board init ...\n", CFG_SYS_BOARD_NAME);
+	return 0;
+}
+
+#if defined(CONFIG_PMIC_NXE2000)||defined(CONFIG_PMIC_AXP228)
+int power_init_board(void)
+{
+	int ret = 0;
+#if defined(CONFIG_PMIC_REG_DUMP)
+	bd_pmic_init();
+#endif
+	ret = power_pmic_function_init();
+	return ret;
+}
+#endif
+
+extern void	bd_display(void);
+
+static void auto_update(int io, int wait)
+{
+	unsigned int grp = PAD_GET_GROUP(io);
+	unsigned int bit = PAD_GET_BITNO(io);
+	int level = 1, i = 0;
+	char *cmd = "fastboot";
+
+	for (i = 0; wait > i; i++) {
+		switch (io & ~(32-1)) {
+		case PAD_GPIO_A:
+		case PAD_GPIO_B:
+		case PAD_GPIO_C:
+		case PAD_GPIO_D:
+		case PAD_GPIO_E:
+			level = NX_GPIO_GetInputValue(grp, bit);	break;
+		case PAD_GPIO_ALV:
+			level = NX_ALIVE_GetInputValue(bit);	break;
+		};
+		if (level)
+			break;
+		mdelay(1);
+	}
+
+	if (i == wait)
+		run_command (cmd, 0);
+}
+
+void bd_display_run(char *cmd, int bl_duty, int bl_on)
+{
+	static int display_init = 0;
+
+
+	if (cmd) {
+		run_command(cmd, 0);
+        lcd_draw_boot_logo(CONFIG_FB_ADDR, CFG_DISP_PRI_RESOL_WIDTH,
+            CFG_DISP_PRI_RESOL_HEIGHT, CFG_DISP_PRI_SCREEN_PIXEL_BYTE);
+	}
+
+	if (!display_init) {
+		bd_display();
+		pwm_init(CFG_LCD_PRI_PWM_CH, 0, 0);
+		display_init = 1;
+	}
+
+	pwm_config(CFG_LCD_PRI_PWM_CH,
+		TO_DUTY_NS(bl_duty, CFG_LCD_PRI_PWM_FREQ),
+		TO_PERIOD_NS(CFG_LCD_PRI_PWM_FREQ));
+
+	if (bl_on)
+		pwm_enable(CFG_LCD_PRI_PWM_CH);
+}
+
+#define	UPDATE_KEY			(PAD_GPIO_ALV + 0)
+#define	UPDATE_CHECK_TIME	(3000)	/* ms */
+
+void lcd_power_on(void)
+{
+	int grp = 0 , bit = 0;
+
+	// Turn On VCC3P3_LCD
+	grp = PAD_GET_GROUP(CFG_IO_LCD_PWREN);
+	bit = PAD_GET_BITNO(CFG_IO_LCD_PWREN);
+	NX_GPIO_SetOutputValue(grp,bit,0);
+
+	mdelay(20);
+
+	// Turn On VSYS_LCD
+	grp = PAD_GET_GROUP(CFG_IO_GATE_PWR_ON);
+	bit = PAD_GET_BITNO(CFG_IO_GATE_PWR_ON);
+	NX_GPIO_SetOutputValue(grp,bit,1);
+}
+
+static void att_watchdog_kick(unsigned sec)
+{
+	char buf[2];
+
+	sec = (sec > 255) ? 255 : sec;
+
+    I2C_SET_BUS(8);
+	buf[0] = sec;
+	i2c_write(AVR_I2C_ADDR, AVR_WDT_COUNTER_ADDR, 1, buf, 1);
+}
+
+void att_watchdog_disable(void)
+{
+	char buf[2];
+
+	buf[0] = 0x69;	// magic number
+	buf[1] = 0x00;	// control register value
+
+    I2C_SET_BUS(8);
+	i2c_write(AVR_I2C_ADDR, AVR_WDT_CTRL_MAGIC_ADDR, 1, buf, 2);
+}
+
+void att_boot_notify(void)	// notify to AVR that we're in u-boot
+{
+	char buf[2];
+
+        I2C_SET_BUS(8);
+	buf[0] = 0;	// dummy
+	i2c_write(AVR_I2C_ADDR, AVR_VERSION_ADDR_FIRST, 1, buf, 1);
+}
+
+int bd_display_boot_menu(int status)
+{
+	//if(status == STATUS_FASTBOOT_MODE)
+	//	bd_display_run(CONFIG_CMD_LOGO_BOOT_MENU_1, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+	//else 
+	if(status == STAUTS_RECOVERY_MODE)
+		bd_display_run(CONFIG_CMD_LOGO_BOOT_MENU_1, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+	else if(status == STATUS_USB_DOWN_MODE)
+		bd_display_run(CONFIG_CMD_LOGO_BOOT_MENU_2, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+	return status;
+}
+
+static int att_check_boot_menu(void)
+{
+	unsigned char val;
+	unsigned char key_stat,key_code;
+	unsigned int status = 0;
+	unsigned int bit = 0;
+	bool button_flag = false;
+	bool status_flag = false;
+	bool power_key_flag = false;
+	
+    I2C_SET_BUS(8);
+	
+	i2c_read(AVR_I2C_ADDR, AVR_RESET_INFO_ADDR, 1, &val, 1);
+	
+	if(val != AVR_RESET_LONG_POWERKEY)
+		return 0;
+	while(1) 
+	{
+			i2c_read(AVR_I2C_ADDR, AVR_BOOT_OPTION_ADDR, 1, &val, 1);
+		
+			if(!(val & 0x80))
+		   		return 0;
+			if(val & 0x40)
+		   		break;
+	}	
+
+	status = STAUTS_RECOVERY_MODE;
+		   
+	while(1) 
+	{
+		bd_display_boot_menu(status);
+		
+		power_key_flag = NX_ALIVE_GetInputValue(bit); // GPIO key input
+		
+		if(power_key_flag == true)
+		{	
+			button_flag = true;			
+		}
+		else
+		{
+			i2c_read(AVR_I2C_ADDR, AVR_KEY_STATUS_ADDR, 1, &key_stat, 1); // I2C Key input
+			i2c_read(AVR_I2C_ADDR, AVR_KEY_CODE_ADDR, 1, &key_code, 1); // I2C Ket Code input	
+			
+			if(key_stat == KEY_STAT_PRESSED && key_code == KEY_CODE_POWER_SHORT && button_flag == true)
+			{
+				status_flag = true;
+			}
+			else if(key_stat == KEY_STAT_PRESSED && key_code == KEY_CODE_POWER_LONG && button_flag == true)
+			{
+			    return status;			
+			}
+			else if(key_stat == KEY_STAT_RELEASED && key_code == KEY_CODE_POWER_SHORT && button_flag == true)
+			{
+				if(status_flag == true)
+				{
+					status++;
+					status_flag = false;
+				}
+				if(status >= 3)
+					status = STAUTS_RECOVERY_MODE;
+			}
+			
+		}
+		
+	}
+}
+
+// SDY -- ota update
+void save_value_of_status() {
+    char buf[2];
+
+    int ret_val = 0;
+    unsigned char val = 0x0;
+
+    I2C_SET_BUS(8);
+
+    ret_val = i2c_read(AVR_I2C_ADDR, AVR_RECOVERY_ADDR, 1, &val, 1);
+
+    printf("SDY -- value is 0x%x, ret : %d\n", val,ret_val);    // SDY -- test
+
+    if (val == 0 || val == 0x3 || val == 0xff) {
+        setenv("bootcmd", "ext4load mmc 2:1 0x40008000 Image;ext4load mmc 2:1 0x49000000 root.img.gz;goimage 0x40008000");  // SDY
+        saveenv();
+    } else if ((val | 0x01) == 0x01) {  // SDY -- system image
+        recovery_mode = 1;
+        val = 0x0;
+
+        i2c_read(AVR_I2C_ADDR, AVR_RECOVERY2_ADDR, 1, &val, 1);
+        if (!(val == 0x01)) {
+            setenv("bootcmd", "ext4load mmc 2:6 0x40008000 Image;ext4load mmc 2:6 0x49000000 ramdisk-recovery.img;goimage 0x40008000");  // SDY
+		    saveenv();
+
+            buf[0] = 1;
+            i2c_write(AVR_I2C_ADDR, AVR_RECOVERY2_ADDR, 1, buf, 1);
+            do_reset (NULL, 0, 0, NULL);
+        }
+    } else if ((val | 0x02) == 0x02) {  // SDY -- recovery image
+        recovery_mode = 0;
+        i2c_write(AVR_I2C_ADDR, AVR_RECOVERY2_ADDR, 1, buf, 1);
+
+        setenv("bootcmd", "ext4load mmc 2:1 0x40008000 Image;ext4load mmc 2:1 0x49000000 ramdisk-recovery.img;goimage 0x40008000");  // SDY
+		saveenv();
+    }
+}
+
+int board_late_init(void)
+{
+#if defined(CONFIG_SYS_MMC_BOOT_DEV)
+	char boot[16];
+	int boot_menu;
+	sprintf(boot, "mmc dev %d", CONFIG_SYS_MMC_BOOT_DEV);
+	run_command(boot, 0);
+#endif
+    att_boot_notify();
+    att_watchdog_kick(WATCHDOG_TIMEOUT);	// kick watchdog
+#if defined CONFIG_RECOVERY_BOOT
+    if (RECOVERY_SIGNATURE == readl(SCR_RESET_SIG_READ)) {
+        writel((-1UL), SCR_RESET_SIG_RESET); /* clear */
+
+        printf("RECOVERY BOOT\n");
+        if (recovery_mode == 1) {
+            bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+        } else {
+            bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS_NORMAL, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+        }
+        run_command(CONFIG_CMD_RECOVERY_BOOT, 0);	/* recovery boot */
+    }
+#endif /* CONFIG_RECOVERY_BOOT */
+
+#if defined CONFIG_UPDATE_BOOT
+    if (UPDATE_SIGNATURE == readl(SCR_RESET_SIG_READ)) {
+        writel((-1UL), SCR_RESET_SIG_RESET); /* clear */
+
+        printf("UPDATE BOOT\n");
+        if (recovery_mode == 1) {
+            bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+        } else {
+            bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS_NORMAL, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+        }
+        run_command(CONFIG_CMD_UPDATE_BOOT, 0);        /* recovery boot */
+    }
+#endif /* CONFIG_RECOVERY_BOOT */
+
+#if defined CONFIG_FASTBOOT
+    if (FASTBOOT_SIGNATURE == readl(SCR_RESET_SIG_READ)) {
+		unsigned char buf = 0;
+        writel((-1UL), SCR_RESET_SIG_RESET); /* clear */
+    
+        printf("FASTBOOT\n");
+
+	    lcd_power_on();
+        if (recovery_mode == 1) {
+            bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+        } else {
+            bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS_NORMAL, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+        }
+        att_watchdog_disable();
+        run_command("fastboot", 0);
+	return 0;
+    }
+#endif /* CONFIG_FASTBOOT_BOOT */
+
+	writel((-1UL), SCR_RESET_SIG_RESET);
+
+	lcd_power_on();
+#if defined(CONFIG_DISPLAY_OUT)
+    if (recovery_mode == 1) {
+        bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+    } else {
+        bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS_NORMAL, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+    }
+#endif
+	att_watchdog_disable();
+    save_value_of_status(); // SDY
+	boot_menu = att_check_boot_menu();
+
+    if(boot_menu == STATUS_FASTBOOT_MODE) 
+	{
+		unsigned char buf = 0;
+        printf("FASTBOOT\n");
+		i2c_write(AVR_I2C_ADDR, AVR_VERSION_ADDR_SECOND, 1, buf, 1);
+		bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS_NORMAL, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+        run_command("fastboot", 0);
+		return 0;
+	}
+	else if(boot_menu == STAUTS_RECOVERY_MODE)
+	{
+		att_watchdog_kick(WATCHDOG_TIMEOUT);	// kick watchdog
+		bd_display_run(CONFIG_CMD_LOGO_WALLPAPERS_NORMAL, CFG_LCD_PRI_PWM_DUTYCYCLE, 1);
+		run_command(CONFIG_CMD_RECOVERY_BOOT, 0);	/* recovery boot */
+		return 0;
+	}
+	else if(boot_menu == STATUS_USB_DOWN_MODE)
+	{
+		
+		unsigned char val1 = 0;
+		unsigned char val2 = 0;
+		unsigned char buf[2];
+		unsigned char counter_reg[2];
+		buf[0] = BOOT_OPTION_USBBOOT;
+		counter_reg[0] = 0x00;
+		
+		i2c_write(AVR_I2C_ADDR, AVR_BOOT_OPTION_ADDR, 1,buf, 1);
+		i2c_read(AVR_I2C_ADDR, AVR_BOOT_OPTION_ADDR, 1, &val1, 1);
+		printf("USB BOOT Dev : val1 : %x\n",val1);
+		i2c_write(AVR_I2C_ADDR, AVR_WDT_COUNTER_ADDR, 1, counter_reg, 1);
+		i2c_read(AVR_I2C_ADDR, AVR_WDT_COUNTER_ADDR, 1, &val2, 1);
+		printf("USB BOOT Dev : val2 : %x\n",val2);
+		//__raw_writel(USBBOOT_SIGNATURE, SCR_RESET_SIG_SET);
+		//__raw_readl(SCR_RESET_SIG_READ);
+		
+		run_command("reset",0);
+		return 0;
+	}
+	att_watchdog_kick(WATCHDOG_TIMEOUT);
+
+#ifdef CONFIG_SYS_BURNING
+    run_command("fastboot nexell", 0);
+    return 0;
+#endif
+
+#if 1
+	//run_command("env default -f -a", 0);
+#endif
+	return 0;
+}
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/config.mk lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/config.mk
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/config.mk	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/config.mk	2017-01-24 18:43:35.365467000 +0900
@@ -0,0 +1,42 @@
+#
+# (C) Copyright 2009
+# jung hyun kim, Nexell Co, <jhkim@nexell.co.kr>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# =========================================================================
+#	Cross compiler
+# =========================================================================
+CROSS_COMPILE := arm-eabi-
+
+# =========================================================================
+#	Build options
+# =========================================================================
+BOARD_CFLAGS += -I$(srctree)/board/$(VENDOR)/$(BOARD)/include
+
+PLATFORM_RELFLAGS += $(BOARD_CFLAGS)
+
+# =========================================================================
+# common debug macro
+# for debug() message
+# =========================================================================
+# PLATFORM_CPPFLAGS += -DDEBUG
+
+
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/display.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/display.c
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/display.c	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/display.c	2017-01-24 18:43:35.365467000 +0900
@@ -0,0 +1,402 @@
+/*
+ * (C) Copyright 2009
+ * jung hyun kim, Nexell Co, <jhkim@nexell.co.kr>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+#include <common.h>
+#include <asm/arch/display.h>
+
+#if defined(CONFIG_DISPLAY_OUT_LVDS)
+extern void display_lvds(int module, unsigned int fbbase,
+					struct disp_vsync_info *pvsync, struct disp_syncgen_param *psgen,
+					struct disp_multily_param *pmly, struct disp_lvds_param *plvds);
+#endif
+
+#if defined(CONFIG_DISPLAY_OUT_RGB)
+extern void display_rgb(int module, unsigned int fbbase,
+					struct disp_vsync_info *pvsync, struct disp_syncgen_param *psgen,
+					struct disp_multily_param *pmly, struct disp_rgb_param *prgb);
+#endif
+
+#if defined(CONFIG_DISPLAY_OUT_HDMI)
+extern void display_hdmi(int module, int preset, unsigned int fbbase,
+					struct disp_vsync_info *pvsync, struct disp_syncgen_param *psgen,
+					struct disp_multily_param *pmly);
+#endif
+
+#if defined(CONFIG_DISPLAY_OUT_MIPI)
+extern void display_mipi(int module, unsigned int fbbase,
+				struct disp_vsync_info *pvsync, struct disp_syncgen_param *psgen,
+				struct disp_multily_param *pmly, struct disp_mipi_param *pmipi);
+
+#define	MIPI_BITRATE_750M
+
+#ifdef MIPI_BITRATE_1G
+#define	PLLPMS		0x33E8
+#define	BANDCTL		0xF
+#elif defined(MIPI_BITRATE_900M)
+#define	PLLPMS		0x2258
+#define	BANDCTL		0xE
+#elif defined(MIPI_BITRATE_840M)
+#define	PLLPMS		0x2230
+#define	BANDCTL		0xD
+#elif defined(MIPI_BITRATE_750M)
+#define	PLLPMS		0x43E8
+#define	BANDCTL		0xC
+#elif defined(MIPI_BITRATE_660M)
+#define	PLLPMS		0x21B8
+#define	BANDCTL		0xB
+#elif defined(MIPI_BITRATE_600M)
+#define	PLLPMS		0x2190
+#define	BANDCTL		0xA
+#elif defined(MIPI_BITRATE_540M)
+#define	PLLPMS		0x2168
+#define	BANDCTL		0x9
+#elif defined(MIPI_BITRATE_512M)
+#define	PLLPMS		0x03200
+#define	BANDCTL		0x9
+#elif defined(MIPI_BITRATE_480M)
+#define	PLLPMS		0x2281
+#define	BANDCTL		0x8
+#elif defined(MIPI_BITRATE_420M)
+#define	PLLPMS		0x2231
+#define	BANDCTL		0x7
+#elif defined(MIPI_BITRATE_402M)
+#define	PLLPMS		0x2219
+#define	BANDCTL		0x7
+#elif defined(MIPI_BITRATE_330M)
+#define	PLLPMS		0x21B9
+#define	BANDCTL		0x6
+#elif defined(MIPI_BITRATE_300M)
+#define	PLLPMS		0x2191
+#define	BANDCTL		0x5
+#elif defined(MIPI_BITRATE_210M)
+#define	PLLPMS		0x2232
+#define	BANDCTL		0x4
+#elif defined(MIPI_BITRATE_180M)
+#define	PLLPMS		0x21E2
+#define	BANDCTL		0x3
+#elif defined(MIPI_BITRATE_150M)
+#define	PLLPMS		0x2192
+#define	BANDCTL		0x2
+#elif defined(MIPI_BITRATE_100M)
+#define	PLLPMS		0x3323
+#define	BANDCTL		0x1
+#elif defined(MIPI_BITRATE_80M)
+#define	PLLPMS		0x3283
+#define	BANDCTL		0x0
+#endif
+
+#define	PLLCTL		0
+#define	DPHYCTL		0
+
+#define MIPI_DELAY 0xFF
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+struct data_val{
+	u8 data[48];
+};
+
+struct mipi_reg_val{
+	u32 cmd;
+	u32 addr;
+	u32 cnt;
+	struct data_val data;
+};
+
+static struct mipi_reg_val mipi_init_data[]=
+{
+ {0x15, 0xB2,    1, {0x7D,}},
+ {0x15, 0xAE,    1, {0x0B,}},
+ {0x15, 0xB6,    1, {0x18,}},
+ {0x15, 0xD2,    1, {0x64,}},
+};
+
+static void  mipilcd_dcs_long_write(U32 cmd, U32 ByteCount, U8* pByteData )
+{
+	U32 DataCount32 = (ByteCount+3)/4;
+	int i = 0;
+	U32 index = 0;
+	volatile NX_MIPI_RegisterSet* pmipi = (volatile NX_MIPI_RegisterSet*)IO_ADDRESS(NX_MIPI_GetPhysicalAddress(index));
+
+	NX_ASSERT( 512 >= DataCount32 );
+
+#if 0
+	printf("0x%02x %2d: ", cmd, ByteCount);
+	for(i=0; i< ByteCount; i++)
+		printf("%02x ", pByteData[i]);
+	printf("\n");
+#endif
+	for( i=0; i<DataCount32; i++ )
+	{
+		pmipi->DSIM_PAYLOAD = (pByteData[3]<<24)|(pByteData[2]<<16)|(pByteData[1]<<8)|pByteData[0];
+		pByteData += 4;
+	}
+
+	pmipi->DSIM_PKTHDR  = (cmd & 0xff) | (ByteCount<<8);
+}
+
+static void mipilcd_dcs_write( unsigned int id, unsigned int data0, unsigned int data1 )
+{
+	U32 index = 0;
+	volatile NX_MIPI_RegisterSet* pmipi = (volatile NX_MIPI_RegisterSet*)IO_ADDRESS(NX_MIPI_GetPhysicalAddress(index));
+
+#if 0
+	switch(id)
+	{
+		case 0x05:
+			printf("0x05  1: %02x \n", data0);
+			break;
+
+		case 0x13:
+			printf("0x13  2: %02x %02x \n", data0, data1);
+			break;
+
+		case 0x15:
+			printf("0x15  2: %02x %02x \n", data0, data1);
+			break;
+	}
+#endif
+
+	pmipi->DSIM_PKTHDR = id | (data0<<8) | (data1<<16);
+}
+
+static int MIPI_LCD_INIT(int width, int height, void *data)
+{
+	int i=0;
+	int size=ARRAY_SIZE(mipi_init_data);
+	u32 index = 0;
+	u32 value = 0;
+	u8 pByteData[48];
+	u8 bitrate=BANDCTL;
+
+	volatile NX_MIPI_RegisterSet* pmipi = (volatile NX_MIPI_RegisterSet*)IO_ADDRESS(NX_MIPI_GetPhysicalAddress(index));
+	value = pmipi->DSIM_ESCMODE;
+	pmipi->DSIM_ESCMODE = value|(3 << 6);
+	value = pmipi->DSIM_ESCMODE;
+	printf("DSIM_ESCMODE : 0x%x\n", value);
+	switch(bitrate)
+	{
+		case 0xF:	printf("MIPI clk: 1000MHz \n");	break;
+		case 0xE:	printf("MIPI clk:  900MHz \n");	break;
+		case 0xD:	printf("MIPI clk:  840MHz \n");	break;
+		case 0xC:	printf("MIPI clk:  760MHz \n");	break;
+		case 0xB:	printf("MIPI clk:  660MHz \n");	break;
+		case 0xA:	printf("MIPI clk:  600MHz \n");	break;
+		case 0x9:	printf("MIPI clk:  540MHz \n");	break;
+		case 0x8:	printf("MIPI clk:  480MHz \n");	break;
+		case 0x7:	printf("MIPI clk:  420MHz \n");	break;
+		case 0x6:	printf("MIPI clk:  330MHz \n");	break;
+		case 0x5:	printf("MIPI clk:  300MHz \n");	break;
+		case 0x4:	printf("MIPI clk:  210MHz \n");	break;
+		case 0x3:	printf("MIPI clk:  180MHz \n");	break;
+		case 0x2:	printf("MIPI clk:  150MHz \n");	break;
+		case 0x1:	printf("MIPI clk:  100MHz \n");	break;
+		case 0x0:	printf("MIPI clk:   80MHz \n");	break;
+		default :	printf("MIPI clk:  unknown \n");	break;
+	}
+
+	mdelay(10);
+
+	for(i=0; i<size; i++)
+	{
+		switch(mipi_init_data[i].cmd)
+		{
+#if 0 // all long packet
+			case 0x05:
+				//pByteData[0] = mipi_init_data[i].addr;
+				//memcpy(&pByteData[1], &mipi_init_data[i].data.data[0], 7);
+				mipilcd_dcs_long_write(0x39, mipi_init_data[i].cnt, &mipi_init_data[i].data.data[0]);
+				break;
+			case 0x15:
+				pByteData[0] = mipi_init_data[i].addr;
+				memcpy(&pByteData[1], &mipi_init_data[i].data.data[0], 7);
+				mipilcd_dcs_long_write(0x39, mipi_init_data[i].cnt+1, &pByteData);
+				break;
+#else
+			case 0x05:
+				mipilcd_dcs_write(mipi_init_data[i].cmd, mipi_init_data[i].data.data[0], 0x00);
+				break;
+
+			case 0x13:
+				mipilcd_dcs_write(mipi_init_data[i].cmd, mipi_init_data[i].addr, mipi_init_data[i].data.data[0]);
+				break;
+
+			case 0x15:
+				mipilcd_dcs_write(mipi_init_data[i].cmd, mipi_init_data[i].addr, mipi_init_data[i].data.data[0]);
+				break;
+#endif
+ 			case 0x39:
+				pByteData[0] = mipi_init_data[i].addr;
+				memcpy(&pByteData[1], &mipi_init_data[i].data.data[0], 48);
+				mipilcd_dcs_long_write(mipi_init_data[i].cmd, mipi_init_data[i].cnt+1, &pByteData[0]);
+				break;
+			case MIPI_DELAY:
+				//printf("delay %d\n", mipi_init_data[i].addr);
+				mdelay(mipi_init_data[i].addr);
+				break;
+		}
+		mdelay(1);
+	}
+
+	value = pmipi->DSIM_ESCMODE;
+	pmipi->DSIM_ESCMODE = value&(~(3 << 6));
+	value = pmipi->DSIM_ESCMODE;
+	printf("DSIM_ESCMODE : 0x%x\n", value);
+
+	mdelay(10);
+	return 0;
+}
+
+#endif
+
+#define	INIT_VIDEO_SYNC(name)								\
+	struct disp_vsync_info name = {							\
+		.h_active_len	= CFG_DISP_PRI_RESOL_WIDTH,         \
+		.h_sync_width	= CFG_DISP_PRI_HSYNC_SYNC_WIDTH,    \
+		.h_back_porch	= CFG_DISP_PRI_HSYNC_BACK_PORCH,    \
+		.h_front_porch	= CFG_DISP_PRI_HSYNC_FRONT_PORCH,   \
+		.h_sync_invert	= CFG_DISP_PRI_HSYNC_ACTIVE_HIGH,   \
+		.v_active_len	= CFG_DISP_PRI_RESOL_HEIGHT,        \
+		.v_sync_width	= CFG_DISP_PRI_VSYNC_SYNC_WIDTH,    \
+		.v_back_porch	= CFG_DISP_PRI_VSYNC_BACK_PORCH,    \
+		.v_front_porch	= CFG_DISP_PRI_VSYNC_FRONT_PORCH,   \
+		.v_sync_invert	= CFG_DISP_PRI_VSYNC_ACTIVE_HIGH,   \
+		.pixel_clock_hz	= CFG_DISP_PRI_PIXEL_CLOCK,   		\
+		.clk_src_lv0	= CFG_DISP_PRI_CLKGEN0_SOURCE,      \
+		.clk_div_lv0	= CFG_DISP_PRI_CLKGEN0_DIV,         \
+		.clk_src_lv1	= CFG_DISP_PRI_CLKGEN1_SOURCE,      \
+		.clk_div_lv1	= CFG_DISP_PRI_CLKGEN1_DIV,         \
+	};
+
+#define	INIT_PARAM_SYNCGEN(name)						\
+	struct disp_syncgen_param name = {						\
+		.interlace 		= CFG_DISP_PRI_MLC_INTERLACE,       \
+		.out_format		= CFG_DISP_PRI_OUT_FORMAT,          \
+		.lcd_mpu_type 	= 0,                                \
+		.invert_field 	= CFG_DISP_PRI_OUT_INVERT_FIELD,    \
+		.swap_RB		= CFG_DISP_PRI_OUT_SWAPRB,          \
+		.yc_order		= CFG_DISP_PRI_OUT_YCORDER,         \
+		.delay_mask		= 0,                                \
+		.vclk_select	= CFG_DISP_PRI_PADCLKSEL,           \
+		.clk_delay_lv0	= CFG_DISP_PRI_CLKGEN0_DELAY,       \
+		.clk_inv_lv0	= CFG_DISP_PRI_CLKGEN0_INVERT,      \
+		.clk_delay_lv1	= CFG_DISP_PRI_CLKGEN1_DELAY,       \
+		.clk_inv_lv1	= CFG_DISP_PRI_CLKGEN1_INVERT,      \
+		.clk_sel_div1	= CFG_DISP_PRI_CLKSEL1_SELECT,		\
+	};
+
+#define	INIT_PARAM_MULTILY(name)					\
+	struct disp_multily_param name = {						\
+		.x_resol		= CFG_DISP_PRI_RESOL_WIDTH,			\
+		.y_resol		= CFG_DISP_PRI_RESOL_HEIGHT,		\
+		.pixel_byte		= CFG_DISP_PRI_SCREEN_PIXEL_BYTE,	\
+		.fb_layer		= CFG_DISP_PRI_SCREEN_LAYER,		\
+		.video_prior	= CFG_DISP_PRI_VIDEO_PRIORITY,		\
+		.mem_lock_size	= 16,								\
+		.rgb_format		= CFG_DISP_PRI_SCREEN_RGB_FORMAT,	\
+		.bg_color		= CFG_DISP_PRI_BACK_GROUND_COLOR,	\
+		.interlace		= CFG_DISP_PRI_MLC_INTERLACE,		\
+	};
+
+#define	INIT_PARAM_LVDS(name)							\
+	struct disp_lvds_param name = {							\
+		.lcd_format 	= CFG_DISP_LVDS_LCD_FORMAT,         \
+	};
+
+#define	INIT_PARAM_RGB(name)							\
+	struct disp_rgb_param name = {							\
+		.lcd_mpu_type 	= 0,                                \
+	};
+
+#define	INIT_PARAM_MIPI(name)	\
+	struct disp_mipi_param name = {	\
+		.pllpms 	= PLLPMS,       \
+		.bandctl	= BANDCTL,      \
+		.pllctl		= PLLCTL,    	\
+		.phyctl		= DPHYCTL,      \
+		.lcd_init	= MIPI_LCD_INIT	\
+	};
+
+int bd_display(void)
+{
+	INIT_VIDEO_SYNC(vsync);
+	INIT_PARAM_SYNCGEN(syncgen);
+	INIT_PARAM_MULTILY(multily);
+
+#if defined(CONFIG_DISPLAY_OUT_LVDS)
+	INIT_PARAM_LVDS(lvds);
+	display_lvds(CFG_DISP_OUTPUT_MODOLE, CONFIG_FB_ADDR,
+		&vsync, &syncgen, &multily, &lvds);
+#endif
+
+#if defined(CONFIG_DISPLAY_OUT_RGB)
+	INIT_PARAM_RGB(rgb);
+
+	display_rgb(CFG_DISP_OUTPUT_MODOLE, CONFIG_FB_ADDR,
+		&vsync, &syncgen, &multily, &rgb);
+#endif
+
+#if defined(CONFIG_DISPLAY_OUT_MIPI)
+	INIT_PARAM_MIPI(mipi);
+
+	/*
+	 * set multilayer parameters
+	 */
+	multily.x_resol =  800;
+	multily.y_resol = 1280;
+
+	/*
+	 * set vsync parameters
+	 */
+	vsync.h_active_len =  800;
+	vsync.v_active_len = 1280;
+	vsync.h_sync_width = 8;
+	vsync.h_back_porch = 40;
+	vsync.h_front_porch = 16;
+	vsync.v_sync_width = 1;
+	vsync.v_back_porch = 2;
+	vsync.v_front_porch = 4;
+
+	/*
+	 * set syncgen parameters
+	 */
+	syncgen.delay_mask = DISP_SYNCGEN_DELAY_RGB_PVD | DISP_SYNCGEN_DELAY_HSYNC_CP1 |
+						  	DISP_SYNCGEN_DELAY_VSYNC_FRAM | DISP_SYNCGEN_DELAY_DE_CP;
+
+	syncgen.d_rgb_pvd = 0;
+	syncgen.d_hsync_cp1	= 0;
+	syncgen.d_vsync_fram = 0;
+	syncgen.d_de_cp2 = 7;
+	syncgen.vs_start_offset = (vsync.h_front_porch + vsync.h_sync_width +
+								vsync.h_back_porch + vsync.h_active_len - 1);
+	syncgen.ev_start_offset = (vsync.h_front_porch + vsync.h_sync_width +
+								vsync.h_back_porch + vsync.h_active_len - 1);
+	syncgen.vs_end_offset = 0;
+	syncgen.ev_end_offset = 0;
+
+	lcd_draw_boot_logo(CONFIG_FB_ADDR, multily.x_resol, multily.y_resol, multily.pixel_byte);
+
+	display_mipi(CFG_DISP_OUTPUT_MODOLE, CONFIG_FB_ADDR,
+		&vsync, &syncgen, &multily, &mipi);
+#endif
+	return 0;
+}
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/eth.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/eth.c
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/eth.c	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/eth.c	2017-01-24 18:43:35.365467000 +0900
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright 2009
+ * jung hyun kim, Nexell Co, <jhkim@nexell.co.kr>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <netdev.h>
+
+/*------------------------------------------------------------------------------
+ * u-boot eth interface
+ */
+#include <net.h>
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+#ifdef	CONFIG_DRIVER_DM9000
+	dm9000_initialize(bis);
+	return eth_init(bis);
+#else	// CONFIG_DRIVER_DM9000
+	return -1;
+#endif
+}
+#endif	/* CONFIG_CMD_NET */
+
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/fastboot_lcd.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/fastboot_lcd.c
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/fastboot_lcd.c	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/fastboot_lcd.c	2017-01-24 18:43:35.365467000 +0900
@@ -0,0 +1,105 @@
+/*
+ * (C) Copyright 2009
+ * jung hyun kim, Nexell Co, <jhkim@nexell.co.kr>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+#include <common.h>
+#include <pwm.h>
+#include <platform.h>
+#include <draw_lcd.h>
+#include <asm/arch/fastboot.h>
+
+#define	LOGO_BGCOLOR	(0xffffff)
+static int _logo_left   = CFG_DISP_PRI_RESOL_WIDTH /2 +  50;
+static int _logo_top    = CFG_DISP_PRI_RESOL_HEIGHT/2 + 180;
+static int _logo_width  = 8*24;
+static int _logo_height = 16;
+
+void fboot_lcd_start(void)
+{
+	lcd_info lcd = {
+		.fb_base		= CONFIG_FB_ADDR,
+		.bit_per_pixel	= CFG_DISP_PRI_SCREEN_PIXEL_BYTE * 8,
+		.lcd_width		= CFG_DISP_PRI_RESOL_WIDTH,
+		.lcd_height		= CFG_DISP_PRI_RESOL_HEIGHT,
+		.back_color		= LOGO_BGCOLOR,
+		.text_color		= 0xFF,
+		.alphablend		= 0,
+	};
+	lcd_debug_init(&lcd);
+
+	/* clear FB */
+	memset((void*)CONFIG_FB_ADDR, 0xFF,
+		CFG_DISP_PRI_RESOL_WIDTH * CFG_DISP_PRI_RESOL_HEIGHT *
+		CFG_DISP_PRI_SCREEN_PIXEL_BYTE);
+
+	run_command(CONFIG_CMD_LOGO_UPDATE, 0);
+	lcd_draw_text("wait for update", _logo_left, _logo_top, 2, 2, 0);
+}
+
+void fboot_lcd_stop(void)
+{
+	run_command(CONFIG_CMD_LOGO_WALLPAPERS, 0);
+}
+
+void fboot_lcd_part(char *part, char *stat)
+{
+	int s = 2;
+	int l = _logo_left, t = _logo_top;
+	int w = (_logo_width*s), h = (_logo_height*s);
+	unsigned bg = LOGO_BGCOLOR;
+
+	lcd_fill_rectangle(l, t, w, h, bg, 0);
+	lcd_draw_string(l, t, s, s, 0, "%s: %s", part, stat);
+}
+
+void fboot_lcd_down(int percent)
+{
+	int s = 2;
+	int l = _logo_left, t = _logo_top;
+	int w = (_logo_width*s), h = (_logo_height*s);
+	unsigned bg = LOGO_BGCOLOR;
+
+	lcd_fill_rectangle(l, t, w, h, bg, 0);
+	lcd_draw_string(l, t, s, s, 0, "down %d%%", percent);
+}
+
+void fboot_lcd_flash(char *part, char *stat)
+{
+	int s = 2;
+	int l = _logo_left, t = _logo_top;
+	int w = (_logo_width*s), h = (_logo_height*s);
+	unsigned bg = LOGO_BGCOLOR;
+
+	lcd_fill_rectangle(l, t, w, h, bg, 0);
+	lcd_draw_string(l, t, s, s, 0, "%s: %s", part, stat);
+}
+
+void fboot_lcd_status(char *stat)
+{
+	int s = 2;
+	int l = _logo_left, t = _logo_top;
+	int w = (_logo_width*s), h = (_logo_height*s);
+	unsigned bg = LOGO_BGCOLOR;
+
+	lcd_fill_rectangle(l, t, w, h, bg, 0);
+	lcd_draw_string(l, t, s, s, 0, "%s", stat);
+}
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_gpio.h lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_gpio.h
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_gpio.h	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_gpio.h	2017-07-10 16:56:52.972539000 +0900
@@ -0,0 +1,261 @@
+/*------------------------------------------------------------------------------
+ *
+ *	Copyright (C) 2009 Nexell Co., Ltd All Rights Reserved
+ *	Nexell Co. Proprietary & Confidential
+ *
+ *	NEXELL INFORMS THAT THIS CODE AND INFORMATION IS PROVIDED "AS IS" BASE
+ *  AND	WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING
+ *  BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
+ *  FOR A PARTICULAR PURPOSE.
+ *
+ *	Module     : System memory config
+ *	Description:
+ *	Author     : Platform Team
+ *	Export     :
+ *	History    :
+ *	   2009/05/13 first implementation
+ ------------------------------------------------------------------------------*/
+#ifndef __CFG_GPIO_H__
+#define __CFG_GPIO_H__
+
+/*------------------------------------------------------------------------------
+ *
+ *	(GROUP_A)
+ *
+ *	0 bit           8 bit                   12 bit          16 bit              20 bit
+ *	| PAD_MODE_XXX  | PAD_FUNC_ALT(0,1,2,3) | PAD_LEVEL_XXX | PAD_PULL_UP,OFF | PAD_STRENGTH_0,1,2,3
+ *
+ -----------------------------------------------------------------------------*/
+#define PAD_GPIOA0      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_2)     // 0: GPIO          ,1: PVCLK               ,2:_                    ,3: TESTMODE[4]         =
+#define PAD_GPIOA1      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[0]          ,2:_                    ,3:_                    =
+#define PAD_GPIOA2      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[1]          ,2:_                    ,3: TESTMODE[0]         =
+#define PAD_GPIOA3      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[2]          ,2:_                    ,3: TESTMODE[1]         =
+#define PAD_GPIOA4      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[3]          ,2:_                    ,3: TESTMODE[2]         =
+#define PAD_GPIOA5      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[4]          ,2:_                    ,3: TESTMODE[3]         =
+#define PAD_GPIOA6      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[5]          ,2:_                    ,3:_                    =
+#define PAD_GPIOA7      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[6]          ,2:_                    ,3:_                    =
+#define PAD_GPIOA8      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[7]          ,2:_                    ,3:_                    =
+#define PAD_GPIOA9      (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[8]          ,2:_                    ,3:_                    =
+#define PAD_GPIOA10     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[9]          ,2:_                    ,3:_                    =
+#define PAD_GPIOA11     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[10]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA12     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[11]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA13     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[12]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA14     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[13]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA15     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[14]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA16     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[15]         ,2:_                    ,3:-                    =
+#define PAD_GPIOA17     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[16]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA18     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[17]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA19     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[18]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA20     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[19]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA21     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[20]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA22     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[21]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA23     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[22]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA24     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: PDRGB24[23]         ,2:_                    ,3:_                    =
+#define PAD_GPIOA25     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: PDVSYNC             ,2:_                    ,3:_                    =
+#define PAD_GPIOA26     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: PDHSYNC             ,2:_                    ,3:_                    =
+#define PAD_GPIOA27     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: PDDE                ,2:_                    ,3:_                    =
+#define PAD_GPIOA28     (PAD_MODE_ALT  | PAD_FUNC_ALT3 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: VP0_EXTCLK          ,2: I2S2_CLK            ,3: I2S1_CLK            =
+#define PAD_GPIOA29     (PAD_MODE_OUT  | PAD_FUNC_ALT0 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: SDMMC0_CCLK         ,2:_                    ,3:_                    =
+#define PAD_GPIOA30     (PAD_MODE_ALT  | PAD_FUNC_ALT3 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[0]          ,2: SDEX[0]             ,3: I2S1_BCLK           =
+#define PAD_GPIOA31     (PAD_MODE_ALT  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW   | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC0_CMD          ,2:_                    ,3:_                    =
+
+/*------------------------------------------------------------------------------
+ *	(GROUP_B)
+ *
+ *	0 bit           8 bit                   12 bit          16 bit              20 bit
+ *	| PAD_MODE_XXX  | PAD_FUNC_ALT(0,1,2,3) | PAD_LEVEL_XXX | PAD_PULL_UP,OFF | PAD_STRENGTH_0,1,2,3
+ *
+ -----------------------------------------------------------------------------*/
+#define PAD_GPIOB0      (PAD_MODE_ALT | PAD_FUNC_ALT3 | PAD_LEVEL_LOW  | PAD_PULL_OFF  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[1]          ,2: SDEX[1]             ,3: I2S1_LRCLK          =
+// hjyoon : AP_GPB1_LTE_RST : Low
+#define PAD_GPIOB1      (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC0_CDATA[0]     ,2:_                    ,3:_                    =
+#define PAD_GPIOB2      (PAD_MODE_IN  | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[2]          ,2: SDEX[2]             ,3: I2S2_BCLK           =
+#define PAD_GPIOB3      (PAD_MODE_IN | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC0_CDATA[1]     ,2:_                    ,3:_                    =
+#define PAD_GPIOB4      (PAD_MODE_IN  | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[3]          ,2: SDEX[3]             ,3: I2S2_LRCLK          =
+#define PAD_GPIOB5      (PAD_MODE_IN | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC0_CDATA[2]     ,2:_                    ,3:_                    =
+#define PAD_GPIOB6      (PAD_MODE_ALT | PAD_FUNC_ALT3 | PAD_LEVEL_LOW  | PAD_PULL_OFF  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[4]          ,2: SDEX[4]             ,3: I2S1SDO             =
+#define PAD_GPIOB7      (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_HIGH  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC0_CDATA[3]     ,2:_                    ,3:_                    =
+#define PAD_GPIOB8      (PAD_MODE_IN  | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[5]          ,2: SDEX[5]             ,3: I2S2SDO             =
+#define PAD_GPIOB9      (PAD_MODE_IN  | PAD_FUNC_ALT3 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[6]          ,2: SDEX[6]             ,3: I2S1SDI             =
+#define PAD_GPIOB10     (PAD_MODE_IN  | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP0_VD[7]          ,2: SDEX[7]             ,3: I2S2SDI             =
+#define PAD_GPIOB11     (PAD_MODE_OUT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: CLE           ,1: CLE1                ,2: GPIO                ,3:_                    =
+#define PAD_GPIOB12     (PAD_MODE_OUT | PAD_FUNC_ALT2 | PAD_LEVEL_HIGH | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: ALE           ,1: ALE1                ,2: GPIO                ,3:_                    =
+#define PAD_GPIOB13     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[0]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB14     (PAD_MODE_OUT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_RnB      ,1: MCUS_RnB1           ,2: GPIO                ,3:_                    =
+#define PAD_GPIOB15     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[1]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB16     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_nNOFE    ,1: MCUS_nNOFE1         ,2: GPIO                ,3:_                    =
+#define PAD_GPIOB17     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[2]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB18     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_nNFWE    ,1: MCUS_nNFWE1         ,2: GPIO                ,3:_                    =
+#define PAD_GPIOB19     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[3]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB20     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[4]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB21     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[5]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB22     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[6]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB23     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[7]    ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOB24     (PAD_MODE_IN  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[8]    ,1: GPIO                ,2: MPEGTSI0_TDATA[0]   ,3:_                    =
+#define PAD_GPIOB25     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[9]    ,1: GPIO                ,2: MPEGTSI0_TDATA[1]   ,3:_                    =
+#define PAD_GPIOB26     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_HIGH  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[10]   ,1: GPIO                ,2: MPEGTSI0_TDATA[2]   ,3: ECID_BONDING_ID[2]  =
+#define PAD_GPIOB27     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[11]   ,1: GPIO                ,2: MPEGTSI0_TDATA[3]   ,3:_                    =
+#define PAD_GPIOB28     (PAD_MODE_ALT | PAD_FUNC_ALT3 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[12]   ,1: GPIO                ,2: MPEGTSI0_TDATA[4]   ,3: UART4_RXD           =
+#define PAD_GPIOB29     (PAD_MODE_ALT | PAD_FUNC_ALT3 | PAD_LEVEL_LOW  | PAD_PULL_OFF  | PAD_STRENGTH_0)     // 0: MCUS_SD[13]   ,1: GPIO                ,2: MPEGTSI0_TDATA[5]   ,3: UART4_TXD           =
+#define PAD_GPIOB30     (PAD_MODE_ALT | PAD_FUNC_ALT3 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[14]   ,1: GPIO                ,2: MPEGTSI0_TDATA[6]   ,3: UART5_RXD           =
+#define PAD_GPIOB31     (PAD_MODE_ALT | PAD_FUNC_ALT3 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_SD[15]   ,1: GPIO                ,2: MPEGTSI0_TDATA[7]   ,3: UART5_TXD           =
+
+/*------------------------------------------------------------------------------
+ *	(GROUP_C)
+ *
+ *	0 bit           8 bit                   12 bit          16 bit              20 bit
+ *	| PAD_MODE_XXX  | PAD_FUNC_ALT(0,1,2,3) | PAD_LEVEL_XXX | PAD_PULL_UP,OFF | PAD_STRENGTH_0,1,2,3
+ *
+ -----------------------------------------------------------------------------*/
+#define PAD_GPIOC0      (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[0]  ,1: GPIO                ,2: MPEGTSI0_TSERR      ,3:_                    =
+#define PAD_GPIOC1      (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[1]  ,1: GPIO                ,2: MPEGTSI1_TSERR      ,3:_                    =
+#define PAD_GPIOC2      (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[2]  ,1: GPIO                ,2:_                    ,3:_                    =
+#define PAD_GPIOC3      (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[3]  ,1: GPIO                ,2: HDMI_CEC            ,3: SDMMC0_nRST         =
+#define PAD_GPIOC4      (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[4]  ,1: GPIO                ,2: UART1_DCD           ,3: SDMMC0_CARD_nint    =
+#define PAD_GPIOC5      (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[5]  ,1: GPIO                ,2: UART1_CTS           ,3: SDMMC0_WP           =
+#define PAD_GPIOC6      (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[6]  ,1: GPIO                ,2: UART1_RTS           ,3: SDMMC0_DETECT       =
+#define PAD_GPIOC7      (PAD_MODE_IN  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[7]  ,1: GPIO                ,2: UART1_DSR           ,3: SDMMC1_nRST         =
+#define PAD_GPIOC8      (PAD_MODE_IN  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[8]  ,1: GPIO                ,2: UART1_DTR           ,3: SDMMC1_CARD_nint    =
+#define PAD_GPIOC9      (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[9]  ,1: GPIO                ,2: SSP2_CLK_IO         ,3: PDM_STROBE          =
+#define PAD_GPIOC10     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[10] ,1: GPIO                ,2: SSP2_FSS            ,3: MCUS_nNCS[2]        =
+#define PAD_GPIOC11     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_HIGH  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[11] ,1: GPIO                ,2: SSP2_RXD            ,3: USB2.0OTG0_DRVBUS   =
+#define PAD_GPIOC12     (PAD_MODE_OUT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[12] ,1: GPIO                ,2: SSP2_TXD            ,3: SDMMC2_nRST         =
+#define PAD_GPIOC13     (PAD_MODE_OUT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_ADDR[13] ,1: GPIO                ,2: PWM1_OUT            ,3: SDMMC2_CARD_nint    =
+//#define PAD_GPIOC14     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[14] ,1: GPIO                ,2: PWM2_OUT            ,3: VIP0_ExtCLK2        =
+#define PAD_GPIOC14     (PAD_MODE_IN | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[14] ,1: GPIO                ,2: PWM2_OUT            ,3: VIP0_ExtCLK2        =
+#define PAD_GPIOC15     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[15] ,1: GPIO                ,2: MPEGTSI0_TSCLK      ,3: VIP0_HSYNC2         =
+#define PAD_GPIOC16     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[16] ,1: GPIO                ,2: MPEGTSI0_TSYNC0     ,3: VIP0_VSYNC2         =
+#define PAD_GPIOC17     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[17] ,1: GPIO                ,2: MPEGTSI0_TDP0       ,3: VIP0_VD2[0]         =
+#define PAD_GPIOC18     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_1)     // 0: MCUS_ADDR[18] ,1: GPIO                ,2: SDMMC2_CCLK         ,3: VIP0_VD2[1]         =
+#define PAD_GPIOC19     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[19] ,1: GPIO                ,2: SDMMC2_CMD          ,3: VIP0_VD2[2]         =
+#define PAD_GPIOC20     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[20] ,1: GPIO                ,2: SDMMC2_CDATA[0]     ,3: VIP0_VD2[3]         =
+#define PAD_GPIOC21     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[21] ,1: GPIO                ,2: SDMMC2_CDATA[1]     ,3: VIP0_VD2[4]         =
+#define PAD_GPIOC22     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[22] ,1: GPIO                ,2: SDMMC2_CDATA[2]     ,3: VIP0_VD2[5]         =
+#define PAD_GPIOC23     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: MCUS_ADDR[23] ,1: GPIO                ,2: SDMMC2_CDATA[3]     ,3: VIP0_VD2[6]         =
+#define PAD_GPIOC24     (PAD_MODE_ALT | PAD_FUNC_ALT2 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: MCUS_LATADDR  ,1: GPIO                ,2: SPDIFIN             ,3: VIP0_VD2[7]         =
+#define PAD_GPIOC25     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_nSWAIT   ,1: GPIO                ,2: SPDIF_DATA          ,3:_                    =
+#define PAD_GPIOC26     (PAD_MODE_IN  | PAD_FUNC_ALT1 | PAD_LEVEL_HIGH | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_RDnWR    ,1: GPIO                ,2: PDM_DATA0           ,3:_                    = DM9000 (IRQ)
+#define PAD_GPIOC27     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: MCUS_nSDQM1   ,1: GPIO                ,2: PDM_DATA1           ,3:_                    =
+#define PAD_GPIOC28     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: MCUS_nSCS[1]        ,2: UART1_TRI           ,3:_                    = DM9000 (ETHERNET)
+#define PAD_GPIOC29     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: SSP0_CLKIO          ,2:_                    ,3:_                    =
+#define PAD_GPIOC30     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: SSP0_FSS            ,2:_                    ,3:_                    =
+#define PAD_GPIOC31     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: SSP0_TXD            ,2:_                    ,3:_                    =
+
+/*------------------------------------------------------------------------------
+ *	(GROUP_D)
+ *
+ *	0 bit           8 bit                   12 bit          16 bit              20 bit
+ *	| PAD_MODE_XXX  | PAD_FUNC_ALT(0,1,2,3) | PAD_LEVEL_XXX | PAD_PULL_UP,OFF | PAD_STRENGTH_0,1,2,3
+ *
+ -----------------------------------------------------------------------------*/
+#define PAD_GPIOD0      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: SSP0_RXD            ,2: PWM3_OUT            ,3:_                    =
+#define PAD_GPIOD1      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: PWM0_OUT            ,2: MCUS_ADDR[25]       ,3:_                    =
+#define PAD_GPIOD2      (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: I2C0_SCL            ,2: UART4_SMCAYEN       ,3:_                    =
+#define PAD_GPIOD3      (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_1)     // 0: GPIO          ,1: I2C0_SDA            ,2: UART5_SMCAYEN       ,3:_                    =
+#define PAD_GPIOD4      (PAD_MODE_IN | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2C1_SCL            ,2:_                    ,3:_                    =
+#define PAD_GPIOD5      (PAD_MODE_IN | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2C1_SDA            ,2:_                    ,3:_                    =
+#define PAD_GPIOD6      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2C2_SCL            ,2:_                    ,3:_                    =
+#define PAD_GPIOD7      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2C2_SDA            ,2:_                    ,3:_                    =
+#define PAD_GPIOD8      (PAD_MODE_IN  | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: PPM_IN              ,2:_                    ,3:_                    =
+#define PAD_GPIOD9      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2S0_SDO            ,2: AC97_ACSDATAOUT     ,3:_                    =
+#define PAD_GPIOD10     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2S0_BCLK           ,2: AC97_ACBITCLK       ,3:_                    =
+#define PAD_GPIOD11     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2S0_SDI            ,2: AC97_ACSDATAIN      ,3:_                    =
+#define PAD_GPIOD12     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2S0_LRCLK          ,2: AC97_ACSYNC         ,3:_                    =
+#define PAD_GPIOD13     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: I2S0_CODCLK         ,2: AC97_nACRESET       ,3:_                    =
+#define PAD_GPIOD14     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART0RXD            ,2: UART1_SMCAYEN       ,3:_                    =
+#define PAD_GPIOD15     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART1RXD            ,2: UART2_SMCAYEN       ,3:_                    =
+#define PAD_GPIOD16     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF  | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART2RXD            ,2: CAN0_TX             ,3:_                    =
+#define PAD_GPIOD17     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_HIGH | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART3RXD            ,2: CAN1_TX             ,3:_                    =
+#define PAD_GPIOD18     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART0TXD            ,2:_                    ,3: SDnCD2              =
+#define PAD_GPIOD19     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART1TXD            ,2:_                    ,3:_                    =
+#define PAD_GPIOD20     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART2TXD            ,2:_                    ,3:_                    =
+#define PAD_GPIOD21     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF  | PAD_STRENGTH_0)     // 0: GPIO          ,1: UART3TXD            ,2:_                    ,3:_                    =
+#define PAD_GPIOD22     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC1_CCLK         ,2:_                    ,3:_                    =
+#define PAD_GPIOD23     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC1_CMD          ,2:_                    ,3:_                    =
+#define PAD_GPIOD24     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC1_CDATA[0]     ,2:_                    ,3:_                    =
+#define PAD_GPIOD25     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC1_CDATA[1]     ,2:_                    ,3:_                    =
+#define PAD_GPIOD26     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC1_CDATA[3]     ,2:_                    ,3:_                    =
+#define PAD_GPIOD27     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          ,1: SDMMC1_CDATA[3]     ,2:_                    ,3:_                    =
+#define PAD_GPIOD28     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP1_VD[0]          ,2: MPEGTSI_TDATA1[0]   ,3: MCUS_ADDR[24]       =
+#define PAD_GPIOD29     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP1_VD[1]          ,2: MPEGTSI_TDATA1[1]   ,3:_                    =
+#define PAD_GPIOD30     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP1_VD[2]          ,2: MPEGTSI_TDATA1[2]   ,3:_                    =
+#define PAD_GPIOD31     (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          ,1: VIP1_VD[3]          ,2: MPEGTSI_TDATA1[3]   ,3:_                    =
+
+/*------------------------------------------------------------------------------
+ *	(GROUP_E)
+ *
+ *	0 bit           8 bit                   12 bit          16 bit              20 bit
+ *	| PAD_MODE_XXX  | PAD_FUNC_ALT(0,1,2,3) | PAD_LEVEL_XXX | PAD_PULL_UP,OFF | PAD_STRENGTH_0,1,2,3
+ *
+ -----------------------------------------------------------------------------*/
+#define PAD_GPIOE0      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: VIP1_VD[4]           ,2: MPEGTSI_TDATA1[0]   ,3:_                    =
+#define PAD_GPIOE1      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: VIP1_VD[5]           ,2: MPEGTSI_TDATA1[0]   ,3:_                    =
+#define PAD_GPIOE2      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: VIP1_VD[6]           ,2: MPEGTSI_TDATA1[0]   ,3:_                    =
+#define PAD_GPIOE3      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: VIP1_VD[7]           ,2: MPEGTSI_TDATA1[0]   ,3:_                    =
+#define PAD_GPIOE4      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: VIP1_ExtCLK          ,2: MPEGTSI_TCLK1       ,3:_                    =
+#define PAD_GPIOE5      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: VIP1_HSYNC           ,2: MPEGTSI_TSYNC1      ,3:_                    =
+#define PAD_GPIOE6      (PAD_MODE_ALT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: VIP_VSYNC            ,2: MPEGTSI_TDP1        ,3:_                    =
+#define PAD_GPIOE7      (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_TXD[0]     ,2: VIP0_Ext_VSYNC      ,3:_                    =
+#define PAD_GPIOE8      (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_TXD[1]     ,2:_                    ,3:_                    =
+#define PAD_GPIOE9      (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_TXD[2]     ,2:_                    ,3:_                    =
+#define PAD_GPIOE10     (PAD_MODE_IN  | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_TXD[3]     ,2:_                    ,3:_                    =
+#define PAD_GPIOE11     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_TXEN       ,2:_                    ,3:_                    =
+#define PAD_GPIOE12     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_HIGH | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_TXER       ,2:_                    ,3:_                    = Backlight Enable
+#define PAD_GPIOE13     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_COL        ,2: VIP0_Ext_HSYNC      ,3:_                    =
+#define PAD_GPIOE14     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_RXD[0]     ,2: SSP1_CLKIO          ,3:_                    =
+#define PAD_GPIOE15     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_RXD[1]     ,2: SSP1_FSS            ,3:_                    =
+#define PAD_GPIOE16     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_HIGH | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_RXD[2]     ,2:_                    ,3:_                    = VG_EN
+#define PAD_GPIOE17     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_RXD[3]     ,2:_                    ,3:_                    =
+#define PAD_GPIOE18     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_CLK_RX         ,2: SSP1_RXD            ,3:_                    =
+#define PAD_GPIOE19     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_RX_DV      ,2: SSP1_TXD            ,3:_                    =
+#define PAD_GPIOE20     (PAD_MODE_OUT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_DN  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_GMII_MDC       ,2:_                    ,3:_                    =
+#define PAD_GPIOE21     (PAD_MODE_ALT  | PAD_FUNC_ALT2 | PAD_LEVEL_HIGH  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_GMII_MDI       ,2: SDMMC2_CDATA[4]     ,3:_                    =
+#define PAD_GPIOE22     (PAD_MODE_ALT  | PAD_FUNC_ALT2 | PAD_LEVEL_HIGH  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_RXER       ,2: SDMMC2_CDATA[5]     ,3:_                    =
+#define PAD_GPIOE23     (PAD_MODE_ALT  | PAD_FUNC_ALT2 | PAD_LEVEL_HIGH  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_PHY_CRS        ,2: SDMMC2_CDATA[6]     ,3:_                    =
+#define PAD_GPIOE24     (PAD_MODE_ALT  | PAD_FUNC_ALT2 | PAD_LEVEL_HIGH  | PAD_PULL_UP  | PAD_STRENGTH_0)     // 0: GPIO          1: GMAC0_GTX_CLK        ,2: SDMMC2_CDATA[7]     ,3:_                    =
+#define PAD_GPIOE25     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: nTRST         1: GPIO                 ,2:_                    ,3:_                    =
+#define PAD_GPIOE26     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: TMS           1: GPIO                 ,2:_                    ,3:_                    =
+#define PAD_GPIOE27     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: TDI           1: GPIO                 ,2:_                    ,3:_                    =
+#define PAD_GPIOE28     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: TCLK          1: GPIO                 ,2:_                    ,3:_                    =
+#define PAD_GPIOE29     (PAD_MODE_ALT | PAD_FUNC_ALT0 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: TDO           1: GPIO                 ,2:_                    ,3:_                    =
+#define PAD_GPIOE30     (PAD_MODE_IN  | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_nSOE     1: GPIO                 ,2:_                    ,3:_                    =
+#define PAD_GPIOE31     (PAD_MODE_OUT | PAD_FUNC_ALT1 | PAD_LEVEL_LOW  | PAD_PULL_OFF | PAD_STRENGTH_0)     // 0: MCUS_nSWE     1: GPIO                 ,2:_                    ,3:_                    =
+
+/*------------------------------------------------------------------------------
+ *	(GROUPALV)
+ *	0                     4                             8        12
+ *	| MODE(IN/OUT/DETECT) | ALIVE OUT or ALIVE DETMODE0 | PullUp |
+ *
+ -----------------------------------------------------------------------------*/
+#define PAD_GPIOALV0    (PAD_MODE_IN  | PAD_LEVEL_LOW  | PAD_PULL_UP )				//
+#define PAD_GPIOALV1    (PAD_MODE_IN  | PAD_LEVEL_LOW  | PAD_PULL_UP )				//
+#define PAD_GPIOALV2    (PAD_MODE_IN  | PAD_LEVEL_LOW  | PAD_PULL_UP )				//
+#define PAD_GPIOALV3    (PAD_MODE_IN  | PAD_LEVEL_LOW  | PAD_PULL_UP )				//
+#define PAD_GPIOALV4    (PAD_MODE_IN  | PAD_LEVEL_LOW  | PAD_PULL_UP )				//
+#define PAD_GPIOALV5    (PAD_MODE_OUT | PAD_LEVEL_HIGH | PAD_PULL_UP )				//
+
+/*------------------------------------------------------------------------------
+ *	GPIO LCD (Backlight Enable/PWM)
+ */
+#define	CFG_IO_LCD_PWREN		    ((PAD_GPIO_C + 11) )		/* GPIO */
+#define CFG_IO_GATE_PWR_ON                  ((PAD_GPIO_B + 25) )        /* SDY --- added for gate power on */
+
+/*------------------------------------------------------------------------------
+ *	GPIO CX20921 RESET
+ */
+#define CFG_IO_CX20921_RESET             (PAD_GPIO_B + 12)   // SDY -- added
+
+/*------------------------------------------------------------------------------
+ *	GPIO EEPROM
+ */
+#define CFG_IO_SPI_EEPROM_WP				((PAD_GPIO_C + 27) | PAD_FUNC_ALT1)		/* GPIO */
+
+
+#define USB_HUB_RESET_PIN           (PAD_GPIO_E+7)
+#define USB_HUB_PORT1_PWR_EN        (PAD_GPIO_E+14)
+#define USB_HUB_PORT2_PWR_EN        (PAD_GPIO_E+15)
+#define USB_HUB_PORT3_PWR_EN        (PAD_GPIO_E+19)
+
+
+#endif	/* __CFG_GPIO_H__ */
+
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_main.h lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_main.h
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_main.h	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_main.h	2017-02-17 22:28:47.666386000 +0900
@@ -0,0 +1,182 @@
+/*------------------------------------------------------------------------------
+ *
+ *	Copyright (C) 2009 Nexell Co., Ltd All Rights Reserved
+ *	Nexell Co. Proprietary & Confidential
+ *
+ *	NEXELL INFORMS THAT THIS CODE AND INFORMATION IS PROVIDED "AS IS" BASE
+ *  AND	WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING
+ *  BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
+ *  FOR A PARTICULAR PURPOSE.
+ *
+ *	Module     : System memory config
+ *	Description:
+ *	Author     : Platform Team
+ *	Export     :
+ *	History    :
+ *	   2009/05/13 first implementation
+ ------------------------------------------------------------------------------*/
+#ifndef __CFG_MAIN_H__
+#define __CFG_MAIN_H__
+
+#include <nx_type.h>
+
+//------------------------------------------------------------------------------
+// PLL input crystal
+//------------------------------------------------------------------------------
+#define	CFG_SYS_PLLFIN		24000000UL
+
+/*------------------------------------------------------------------------------
+ * 	System Name
+ */
+#define	CFG_SYS_CPU_NAME						"s5p6818"
+#define	CFG_SYS_BOARD_NAME						"s5p6818-navi"
+
+/*------------------------------------------------------------------------------
+ * 	Debug Uart
+ */
+#define CFG_UART_DEBUG_CH						3	
+#define CFG_UART_DEBUG_BAUDRATE					115200
+#define CFG_UART_DEBUG_USE_UART					CTRUE
+#define	CFG_UART_CLKGEN_CLOCK_HZ				14750000	// 50000000
+
+/*------------------------------------------------------------------------------
+ * 	Timer List
+ */
+#define	CFG_TIMER_SYS_TICK_CH					0
+
+/*------------------------------------------------------------------------------
+ * 	Extern Ethernet
+ */
+#define CFG_ETHER_EXT_PHY_BASEADDR          	0x04000000	// DM9000: CS1
+#define	CFG_ETHER_EXT_IRQ_NUM					(IRQ_GPIO_C_START + 26)
+
+/*------------------------------------------------------------------------------
+ * 	Nand (HWECC)
+ */
+#define CFG_NAND_ECC_BYTES                      1024            /* 512 - 4,8,16,24  1024 - 24,40,60  */
+#define CFG_NAND_ECC_BITS                       40
+
+/*------------------------------------------------------------------------------
+ *	Nand (GPIO)
+ */
+#define CFG_IO_NAND_nWP							(PAD_GPIO_C + 27)		/* GPIO */
+
+/*------------------------------------------------------------------------------
+ * 	Display (DPC and MLC)
+ */
+#define CFG_DISP_OUTPUT_MODOLE           	0	// 0 : Primary, 1 : Secondary
+
+#define CFG_DISP_PRI_SCREEN_LAYER               1
+#define CFG_DISP_PRI_SCREEN_RGB_FORMAT          MLC_RGBFMT_A8R8G8B8
+#define CFG_DISP_PRI_SCREEN_PIXEL_BYTE	        4
+#define CFG_DISP_PRI_SCREEN_COLOR_KEY	        0x090909
+
+#define CFG_DISP_PRI_VIDEO_PRIORITY		2	// 0, 1, 2, 3
+#define CFG_DISP_PRI_BACK_GROUND_COLOR	     	0x000000
+
+#define CFG_DISP_PRI_MLC_INTERLACE              CFALSE
+
+#define CFG_DISP_PRI_RESOL_WIDTH          	    1280    // 1024	// X Resolution     // SDY
+#define CFG_DISP_PRI_RESOL_HEIGHT		        480     // 600	// Y Resolution     // SDY
+
+//#define CFG_DISP_PRI_HSYNC_SYNC_WIDTH           3       //20    // SDY  (HBLANK : 3 + 92 + 92 = 187)
+#define CFG_DISP_PRI_HSYNC_SYNC_WIDTH           60       //hjyoon  (HBLANK : 60 + 30 + 30 = 120)
+//#define CFG_DISP_PRI_HSYNC_BACK_PORCH           92      //160   // SDY  (HTOTAL : 1280 + 187 = 1467)
+#define CFG_DISP_PRI_HSYNC_BACK_PORCH           30      //hjyoon  (HTOTAL : 1280 + 120 = 1400)
+//#define CFG_DISP_PRI_HSYNC_FRONT_PORCH          92      //160   // SDY
+#define CFG_DISP_PRI_HSYNC_FRONT_PORCH          30      //hjyoon
+#define CFG_DISP_PRI_HSYNC_ACTIVE_HIGH          CTRUE
+#define CFG_DISP_PRI_VSYNC_SYNC_WIDTH           26       //3     // SDY  (VBLANK : 26 + 12 + 12 = 50)
+//#define CFG_DISP_PRI_VSYNC_BACK_PORCH           43      //23    // SDY  (VTOTAL : 480 + 88 = 568)
+#define CFG_DISP_PRI_VSYNC_BACK_PORCH           12      //hjyoon  (VTOTAL : 480 + 50 = 530)
+//#define CFG_DISP_PRI_VSYNC_FRONT_PORCH          43      //12    // SDY
+#define CFG_DISP_PRI_VSYNC_FRONT_PORCH          12      //hjyoon
+#define CFG_DISP_PRI_VSYNC_ACTIVE_HIGH 	        CTRUE
+
+#define CFG_DISP_PRI_CLKGEN0_SOURCE             DPC_VCLK_SRC_PLL0
+//#define CFG_DISP_PRI_CLKGEN0_DIV                16 //20     // SDY --- default value : 20(40 Mhz), now value : 16(50 Mhz)
+#define CFG_DISP_PRI_CLKGEN0_DIV                18 // hjyoon -- 44.4Mhz
+#define CFG_DISP_PRI_CLKGEN0_DELAY              0
+#define CFG_DISP_PRI_CLKGEN0_INVERT				0
+#define CFG_DISP_PRI_CLKGEN1_SOURCE             DPC_VCLK_SRC_VCLK2
+#define CFG_DISP_PRI_CLKGEN1_DIV                1
+#define CFG_DISP_PRI_CLKGEN1_DELAY              0
+#define CFG_DISP_PRI_CLKGEN1_INVERT		0
+#define CFG_DISP_PRI_CLKSEL1_SELECT		0
+#define CFG_DISP_PRI_PADCLKSEL                  DPC_PADCLKSEL_VCLK	/* VCLK=CLKGEN1, VCLK12=CLKGEN0 */
+
+#define	CFG_DISP_PRI_PIXEL_CLOCK				80000000/CFG_DISP_PRI_CLKGEN0_DIV
+
+#define	CFG_DISP_PRI_OUT_SWAPRB 		CFALSE
+#define CFG_DISP_PRI_OUT_FORMAT                 DPC_FORMAT_RGB666
+#define CFG_DISP_PRI_OUT_YCORDER                DPC_YCORDER_CbYCrY
+#define CFG_DISP_PRI_OUT_INTERLACE              CFALSE
+#define CFG_DISP_PRI_OUT_INVERT_FIELD           CFALSE
+
+/*------------------------------------------------------------------------------
+ * 	LVDS
+ */
+#define CFG_DISP_LVDS_LCD_FORMAT             	LVDS_LCDFORMAT_VESA
+
+/*------------------------------------------------------------------------------
+ *  SPI
+ */
+#define CFG_SPI0_SRC_CLK                            100*1000*1000
+#define CFG_SPI0_OUT_CLK                            20*1000*1000
+
+#define CFG_SPI1_SRC_CLK                            100*1000*1000
+#define CFG_SPI1_OUT_CLK                            30*1000*1000
+
+#define CFG_SPI2_SRC_CLK                            100*1000*1000
+#define CFG_SPI2_OUT_CLK                            30*1000*1000
+
+
+/*------------------------------------------------------------------------------
+ * 	TIMER/PWM
+ */
+#define CFG_LCD_PRI_PWM_CH                      0
+#define CFG_LCD_PRI_PWM_FREQ                    10000
+#define CFG_LCD_PRI_PWM_DUTYCYCLE               50      /* (%) */
+
+
+#define USB2514_I2C_ADDR            (0x58 >> 1)
+#define CONFIG_USB2414_HUB_BUS          I2C_4
+
+
+//------------------------------------------------------------------------------
+// Static Bus #0 ~ #9, NAND, IDE configuration
+//------------------------------------------------------------------------------
+//	_BW	  : Staic Bus width for Static #0 ~ #9            : 8 or 16
+//
+//	_TACS : adress setup time before chip select          : 0 ~ 15
+//	_TCOS : chip select setup time before nOE is asserted : 0 ~ 15
+//	_TACC : access cycle                                  : 1 ~ 256
+//	_TSACC: burst access cycle for Static #0 ~ #9 & IDE   : 1 ~ 256
+//	_TOCH : chip select hold time after nOE not asserted  : 0 ~ 15
+//	_TCAH : address hold time after nCS is not asserted   : 0 ~ 15
+//
+//	_WAITMODE : wait enable control for Static #0 ~ #9 & IDE : 1=disable, 2=Active High, 3=Active Low
+//	_WBURST	  : burst write mode for Static #0 ~ #9          : 0=disable, 1=4byte, 2=8byte, 3=16byte
+//	_RBURST   : burst  read mode for Static #0 ~ #9          : 0=disable, 1=4byte, 2=8byte, 3=16byte
+//
+//------------------------------------------------------------------------------
+#define CFG_SYS_STATICBUS_CONFIG( _name_, bw, tACS, tCOS, tACC, tSACC, tCOH, tCAH, wm, rb, wb )	\
+	enum {											\
+		CFG_SYS_ ## _name_ ## _BW		= bw,		\
+		CFG_SYS_ ## _name_ ## _TACS		= tACS,		\
+		CFG_SYS_ ## _name_ ## _TCOS		= tCOS,		\
+		CFG_SYS_ ## _name_ ## _TACC		= tACC,		\
+		CFG_SYS_ ## _name_ ## _TSACC	= tSACC,	\
+		CFG_SYS_ ## _name_ ## _TCOH		= tCOH,		\
+		CFG_SYS_ ## _name_ ## _TCAH		= tCAH,		\
+		CFG_SYS_ ## _name_ ## _WAITMODE	= wm, 		\
+		CFG_SYS_ ## _name_ ## _RBURST	= rb, 		\
+		CFG_SYS_ ## _name_ ## _WBURST	= wb		\
+	};
+
+//                      ( _name_ , bw, tACS tCOS tACC tSACC tOCH tCAH, wm, rb, wb )
+CFG_SYS_STATICBUS_CONFIG( STATIC0 ,  8,    1,   1,   6,    6,   1,   1,  1,  0,  0 )		// 0x0000_0000
+CFG_SYS_STATICBUS_CONFIG( STATIC1 ,  8,    6,   6,  32,   32,   6,   6,  1,  0,  0 )		// 0x0400_0000
+CFG_SYS_STATICBUS_CONFIG(    NAND ,  8,    0,   0xf,0x3f,  1, 0xf,   0,  1,  0,  0 )		// 0x2C00_0000, tOCH, tCAH must be greter than 0
+
+#endif /* __CFG_MAIN_H__ */
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_mem.h lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_mem.h
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_mem.h	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/cfg_mem.h	2017-02-06 16:33:03.989874000 +0900
@@ -0,0 +1,21 @@
+/*------------------------------------------------------------------------------
+ *
+ *	Copyright (C) 2009 Nexell Co., Ltd All Rights Reserved
+ *	Nexell Co. Proprietary & Confidential
+ *
+ *	NEXELL INFORMS THAT THIS CODE AND INFORMATION IS PROVIDED "AS IS" BASE
+ *  AND	WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING
+ *  BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
+ *  FOR A PARTICULAR PURPOSE.
+ *
+ ------------------------------------------------------------------------------*/
+#ifndef __CFG_MEM_H__
+#define __CFG_MEM_H__
+
+/*------------------------------------------------------------------------------
+ * 	 System memory map
+ */
+#define	CFG_MEM_PHY_SYSTEM_BASE			0x40000000	/* System, must be at an evne 2MB boundary (head.S) */
+#define	CFG_MEM_PHY_SYSTEM_SIZE			0x80000000	/* 2G MB */
+
+#endif /* __CFG_MEM_H__ */
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/nxe2000_power.h lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/nxe2000_power.h
--- repo_avn/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/nxe2000_power.h	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/board/s5p6818/navi/include/nxe2000_power.h	2017-01-24 18:43:35.365467000 +0900
@@ -0,0 +1,262 @@
+/*
+ * (C) Copyright 2013
+ * bong kwan kook, Nexell Co, <kook@nexell.co.kr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __NXE2000_POWER_H_
+#define __NXE2000_POWER_H_
+
+#include <power/pmic.h>
+#include <platform.h>
+#include "nxe2000-private.h"
+
+
+/*
+ *	Config Value
+ */
+
+#define NXE2000_I2C_ADDR					(0x64 >> 1)
+
+#define CHARGER_MIN_CURRENT					100		/* VAL(mV) */
+#define CHARGER_MAX_CURRENT					800		/* VAL(mV) */
+#define CHARGER_CURRENT_RESOLUTION			100		/* VAL(mV) */
+#define CHARGER_CURRENT_COMPLETE			3		/* (n + 1) x 50mA   */
+
+#define GPIO_OTG_USBID_DET					(-1)
+#define GPIO_OTG_VBUS_DET					(-1)
+#define GPIO_PMIC_VUSB_DET					(-1)
+#define GPIO_PMIC_LOWBAT_DET				(-1)
+#define GPIO_POWER_KEY_DET					(PAD_GPIO_ALV + 0)
+
+/*
+ *	Default Value
+ */
+
+#define	NXE2000_DEF_OFF_PRESS_TIME			5		/* VAL = 0:0, 1:1, 2:2, 3:4, 4:6, 5:8, 6:10, 7:12 sec */
+
+#define NXE2000_DEF_LIMIT_ADP_AMP			2500000	/* VAL(mA), MAX = 2500mA */
+#define NXE2000_DEF_LIMIT_USB_AMP			1500000	/* VAL(mA), MAX = 1500mA */
+#define NXE2000_DEF_LIMIT_USBDATA_AMP		 500000	/* VAL(mA), MAX = 1500mA */
+
+#define NXE2000_DEF_CHG_ADP_AMP				1500000	/* VAL(mA), MAX = 1800mA */
+#define NXE2000_DEF_CHG_USB_AMP				1500000	/* VAL(mA), MAX = 1800mA */
+
+#define	NXE2000_DEF_CUTOFF_VOL				3300000	/* VAL(uV), No Charger */		/* Refer form ADC	*/
+#define	NXE2000_DEF_LOWBAT_BATTERY_VOL		3500000	/* VAL(uV), No Charger */		/* Refer form ADC	*/
+#define	NXE2000_DEF_LOWBAT_USB_PC_VOL		3600000	/* VAL(uV), USB Charger */		/* Refer form ADC	*/
+#define	NXE2000_DEF_LOWBAT_USB_ADP_VOL		3660000	/* VAL(uV), USB Charger  */	/* Refer form ADC	*/
+#define	NXE2000_DEF_LOWBAT_ADP_VOL			3660000	/* VAL(uV), ADP Charger  */	/* Refer form ADC	*/
+
+#define	NXE2000_DEF_DDC1_ON					1		/* VAL = 0: Off, 1: On, default(OTP) = On */	/* 1.3V ARM		*/
+#define	NXE2000_DEF_DDC2_ON					1		/* VAL = 0: Off, 1: On, default(OTP) = On */	/* 1.2V CORE	*/
+#define	NXE2000_DEF_DDC3_ON					1		/* VAL = 0: Off, 1: On, default(OTP) = On */	/* 3.3V SYS		*/
+#define	NXE2000_DEF_DDC4_ON					1		/* VAL = 0: Off, 1: On, default(OTP) = On */	/* 1.6V DDR		*/
+#define	NXE2000_DEF_DDC5_ON					1		/* VAL = 0: Off, 1: On, default(OTP) = On */	/* 1.6V SYS		*/
+
+#define	NXE2000_DEF_LDO1_ON					0		/* VAL = 0: Off, 1: On */	/* 3.3V GPS & WIFI	*/
+#define	NXE2000_DEF_LDO2_ON					0		/* VAL = 0: Off, 1: On */	/* 1.8V CAM1	*/
+#define	NXE2000_DEF_LDO3_ON					1		/* VAL = 0: Off, 1: On */	/* 1.8V SYS1,	Boot On	*/
+#define	NXE2000_DEF_LDO4_ON					1		/* VAL = 0: Off, 1: On */	/* 1.9V SYS,		Boot On	*/
+#define	NXE2000_DEF_LDO5_ON					0		/* VAL = 0: Off, 1: On */	/* 2.8V CAM		*/
+#define	NXE2000_DEF_LDO6_ON					1		/* VAL = 0: Off, 1: On */	/* 3.3V ALIVE,	Boot On	*/
+#define	NXE2000_DEF_LDO7_ON					0		/* VAL = 0: Off, 1: On */	/* 2.8V VID,		Boot On	*/
+#define	NXE2000_DEF_LDO8_ON					0		/* VAL = 0: Off, 1: On */	/* 3.3V none,	Not Use	*/
+#define	NXE2000_DEF_LDO9_ON					0		/* VAL = 0: Off, 1: On */	/* 3.3V none,	Not Use	*/
+#define	NXE2000_DEF_LDO10_ON				1		/* VAL = 0: Off, 1: On */	/* 1.2V none,	Not Use	*/
+#define	NXE2000_DEF_LDORTC1_ON				1		/* VAL = 0: Off, 1: On */	/* 1.8V ALIVE,	Boot On	*/
+#define	NXE2000_DEF_LDORTC2_ON				1		/* VAL = 0: Off, 1: On */	/* 1.0V ALIVE,	Boot On	*/
+
+#define	NXE2000_DEF_DDC1_VOL				1250000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.3V */
+#define	NXE2000_DEF_DDC2_VOL				1200000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.2V */
+#define	NXE2000_DEF_DDC3_VOL				3300000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 3.3V */
+#define	NXE2000_DEF_DDC4_VOL				1500000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.6V */
+#define	NXE2000_DEF_DDC5_VOL				1500000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.6V */
+
+#define	NXE2000_DEF_DDC1_SLP_VOL			1250000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.3V */
+#define	NXE2000_DEF_DDC2_SLP_VOL			1100000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.2V */
+#define	NXE2000_DEF_DDC3_SLP_VOL			3300000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 3.3V */
+#define	NXE2000_DEF_DDC4_SLP_VOL			1500000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.6V */
+#define	NXE2000_DEF_DDC5_SLP_VOL			1500000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step 12.5 mV, default(OTP) = 1.6V */
+
+#define	NXE2000_DEF_LDO1_VOL				3300000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO2_VOL				1800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.80V */
+#define	NXE2000_DEF_LDO3_VOL				1800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.80V */
+#define	NXE2000_DEF_LDO4_VOL				1800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.90V */
+#define	NXE2000_DEF_LDO5_VOL				2800000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step = 25mV, default(OTP) = 2.80V */
+#define	NXE2000_DEF_LDO6_VOL				3300000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO7_VOL				2800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 2.80V */
+#define	NXE2000_DEF_LDO8_VOL				3300000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO9_VOL				3300000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO10_VOL				1200000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.20V */
+#define	NXE2000_DEF_LDORTC1_VOL				1800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDORTC2_VOL				1000000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.20V */
+
+#define	NXE2000_DEF_LDO1_SLP_VOL			3300000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO2_SLP_VOL			1800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.80V */
+#define	NXE2000_DEF_LDO3_SLP_VOL			1800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.80V */
+#define	NXE2000_DEF_LDO4_SLP_VOL			1800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.90V */
+#define	NXE2000_DEF_LDO5_SLP_VOL			2800000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step = 25mV, default(OTP) = 2.80V */
+#define	NXE2000_DEF_LDO6_SLP_VOL			3300000	/* VAL(uV) = 0: 0.60 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO7_SLP_VOL			2800000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 2.80V */
+#define	NXE2000_DEF_LDO8_SLP_VOL			3300000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO9_SLP_VOL			3300000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 3.30V */
+#define	NXE2000_DEF_LDO10_SLP_VOL			1000000	/* VAL(uV) = 0: 0.90 ~ 3.5V, Step = 25mV, default(OTP) = 1.20V */
+
+#define	NXE2000_DEF_DDCx_VOL_STEP			12500	/* UINT = 1uV, 12.5mV */
+#define	NXE2000_DEF_LDOx_VOL_STEP			25000	/* UINT = 1uV, 25mV */
+
+#define	NXE2000_DEF_DDCx_VOL_MIN			600000	/* UINT = 1uV, 0.6V */
+#define	NXE2000_DEF_DDCx_VOL_MAX			3500000	/* UINT = 1uV, 3.5V */
+
+#define	NXE2000_DEF_LDOx_VOL_MIN			900000	/* UINT = 1uV, 0.9V */
+#define	NXE2000_DEF_LDOx_VOL_MAX			3500000	/* UINT = 1uV, 3.5V */
+#define	NXE2000_DEF_LDO56_VOL_MIN			600000	/* UINT = 1uV, 0.6V */
+#define	NXE2000_DEF_LDO56_VOL_MAX			3500000	/* UINT = 1uV, 3.5V */
+#define	NXE2000_DEF_LDORTC1_VOL_MIN			1700000	/* UINT = 1uV, 1.7V */
+#define	NXE2000_DEF_LDORTC1_VOL_MAX			3500000	/* UINT = 1uV, 3.5V */
+
+#define	NXE2000_DEF_DDC1_SLP_MODE			0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC2_SLP_MODE			0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC3_SLP_MODE			0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC4_SLP_MODE			0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC5_SLP_MODE			0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+
+#define	NXE2000_DEF_DDC1_MODE				0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC2_MODE				0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC3_MODE				0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC4_MODE				0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+#define	NXE2000_DEF_DDC5_MODE				0		/* VAL = 0:AUTO(default), 1:PWM, 2:PSM, 3:AUTO */
+
+#define	NXE2000_DEF_DDC1_DSC_CTRL			1		/* VAL = 0: Off, 1: On(default) */
+#define	NXE2000_DEF_DDC2_DSC_CTRL			1		/* VAL = 0: Off, 1: On(default) */
+#define	NXE2000_DEF_DDC3_DSC_CTRL			1		/* VAL = 0: Off, 1: On(default) */
+#define	NXE2000_DEF_DDC4_DSC_CTRL			1		/* VAL = 0: Off, 1: On(default) */
+#define	NXE2000_DEF_DDC5_DSC_CTRL			1		/* VAL = 0: Off, 1: On(default) */
+
+#define	NXE2000_DEF_DDC1_OSC_FREQ			0		/* VAL(MHz) = 0: 1.5, 1: prohibit, 2: 3.0, 3: prohibit, default(OTP) = 1.5MHz */
+#define	NXE2000_DEF_DDC2_OSC_FREQ			0		/* VAL(MHz) = 0: 1.5, 1: prohibit, 2: 3.0, 3: prohibit, default(OTP) = 1.5MHz */
+#define	NXE2000_DEF_DDC3_OSC_FREQ			0		/* VAL(MHz) = 0: 1.5, 1: prohibit, 2: 3.0, 3: prohibit, default(OTP) = 1.5MHz */
+#define	NXE2000_DEF_DDC4_OSC_FREQ			0		/* VAL(MHz) = 0: 1.5, 1: prohibit, 2: 3.0, 3: prohibit, default(OTP) = 1.5MHz */
+#define	NXE2000_DEF_DDC5_OSC_FREQ			0		/* VAL(MHz) = 0: 1.5, 1: prohibit, 2: 3.0, 3: prohibit, default(OTP) = 1.5MHz */
+
+#define	NXE2000_DEF_DDC1_RAMP_SLOP			0		/* VAL(mV/us) = 0: 14, 1: 7, 2: 3.5, 3: prohibit, default = 14mV/us */
+#define	NXE2000_DEF_DDC2_RAMP_SLOP			0		/* VAL(mV/us) = 0: 14, 1: 7, 2: 3.5, 3: prohibit, default = 14mV/us */
+#define	NXE2000_DEF_DDC3_RAMP_SLOP			0		/* VAL(mV/us) = 0: 14, 1: 7, 2: 3.5, 3: prohibit, default = 14mV/us */
+#define	NXE2000_DEF_DDC4_RAMP_SLOP			0		/* VAL(mV/us) = 0: 14, 1: 7, 2: 3.5, 3: prohibit, default = 14mV/us */
+#define	NXE2000_DEF_DDC5_RAMP_SLOP			0		/* VAL(mV/us) = 0: 14, 1: 7, 2: 3.5, 3: prohibit, default = 14mV/us */
+
+#define	NXE2000_DEF_DDC1_CUR_LIMIT			3		/* VAL(A) = 0: No limit, 1: 3.2A, 2: 3.7A, 3: 4.0A, default(OTP) = 3.2A */
+#define	NXE2000_DEF_DDC2_CUR_LIMIT			3		/* VAL(A) = 0: No limit, 1: 3.2A, 2: 3.7A, 3: 4.0A, default(OTP) = 3.2A */
+#define	NXE2000_DEF_DDC3_CUR_LIMIT			1		/* VAL(A) = 0: No limit, 1: 3.2A, 2: 3.7A, 3: 4.0A, default(OTP) = 3.2A */
+#define	NXE2000_DEF_DDC4_CUR_LIMIT			1		/* VAL(A) = 0: No limit, 1: 3.2A, 2: 3.7A, 3: 4.0A, default(OTP) = 3.2A */
+#define	NXE2000_DEF_DDC5_CUR_LIMIT			1		/* VAL(A) = 0: No limit, 1: 3.2A, 2: 3.7A, 3: 4.0A, default(OTP) = 3.2A */
+
+#define	NXE2000_DEF_DDC1_LIMSHUT_EN			0		/* VAL = 0: Disable, 1: Enable */
+#define	NXE2000_DEF_DDC2_LIMSHUT_EN			0		/* VAL = 0: Disable, 1: Enable */
+#define	NXE2000_DEF_DDC3_LIMSHUT_EN			1		/* VAL = 0: Disable, 1: Enable */
+#define	NXE2000_DEF_DDC4_LIMSHUT_EN			1		/* VAL = 0: Disable, 1: Enable */
+#define	NXE2000_DEF_DDC5_LIMSHUT_EN			1		/* VAL = 0: Disable, 1: Enable */
+
+#define	NXE2000_DEF_ADC_AIN0				0		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+#define	NXE2000_DEF_ADC_AIN1				0		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+#define	NXE2000_DEF_ADC_VTHM				0		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+#define	NXE2000_DEF_ADC_VSYS				1		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+#define	NXE2000_DEF_ADC_VUSB				0		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+#define	NXE2000_DEF_ADC_VADP				0		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+#define	NXE2000_DEF_ADC_VBAT				1		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+#define	NXE2000_DEF_ADC_ILIM				0		/* VAL = 0: Disable, 1: Enable, default = Disable*/
+
+#define	NXE2000_DEF_ADCCNT3_ADRQ			2		/* VAL = 0: Stop, 1: Single-mode, 2: Auto-mode, 3: Prohibit, default = Stop*/
+#define	NXE2000_DEF_ADCCNT3_AVE				1		/* VAL = 0: one-time, 1: average of four-time, default = one-time*/
+#define	NXE2000_DEF_ADCCNT3_ADSEL			0		/* Select input of ADC in single-mode A/D conbersion */
+
+#define NXE2000_DEF_CHG_PRIORITY			0		/* VAL = 0: VADP,	1:VUSB, 	default = VUSB */
+#define NXE2000_DEF_CHG_COMPLETE_DIS		0		/* VAL = 0: Enable,	1: Disable,	default = Enable */
+#define NXE2000_DEF_CHG_NOBAT_OVLIM_EN		0		/* VAL = 0: Off, 		1: On, 	default = On */
+#define NXE2000_DEF_CHG_OTG_BOOST			0		/* VAL = 0: Off, 		1: On, 	default = On */
+#define NXE2000_DEF_CHG_SUSPEND				0		/* VAL = 0: Off, 		1: On, 	default = Off */
+#define NXE2000_DEF_CHG_JEITAEN				0		/* VAL = 0: Off, 		1: On, 	default = Off */
+#define NXE2000_DEF_CHG_USB_EN				1		/* VAL = 0: Off, 		1: On, 	default = On */
+#define NXE2000_DEF_CHG_ADP_EN				1		/* VAL = 0: Off, 		1: On, 	default = On */
+
+#define NXE2000_DEF_CHG_USB_VCONTMASK		0		/* VAL = 0: Off, 1: On, default(OTP) = Off */
+#define NXE2000_DEF_CHG_ADP_VCONTMASK		0		/* VAL = 0: Off, 1: On, default(OTP) = Off */
+#define NXE2000_DEF_CHG_VUSB_BUCK_THS		0		/* VAL(V) = 0: 4.1 ~ 4.2, 1: 4.2 ~ 4.3, 2: 4.3 ~ 4.4, 3: 4.4 ~ 4.5, default(OTP) = 4.1 ~ 4.2V */
+#define NXE2000_DEF_CHG_VADP_BUCK_THS		0		/* VAL(V) = 0: 4.1 ~ 4.2, 1: 4.2 ~ 4.3, 2: 4.3 ~ 4.4, 3: 4.4 ~ 4.5, default(OTP) = 4.1 ~ 4.2V */
+
+#define NXE2000_DEF_CHG_VSYS_VOL			3		/* VAL(V) = 0: 3.60, 1: 4.00, 2: 4.40, 3: 4.55, default = 4.00V */
+#define NXE2000_DEF_CHG_VSYS_OVER_VOL		1		/* VAL(V) = 0: 4.8 ~ 5.3, 1: 5.0 ~ 5.5, 2: 5.2 ~ 5.7, 3: 5.2 ~ 5.7, default = 5.0 ~ 5.5V */
+
+#define NXE2000_DEF_CHG_RAPID_TTIM_40		0
+#define NXE2000_DEF_CHG_RAPID_TTIM_80		1
+#define NXE2000_DEF_CHG_RAPID_TTIMDIS		2
+#define NXE2000_DEF_CHG_RAPID_CTIME			2		/* VAL(sec) = 0: 0.1, 1: 0.5, 2: 1 3: 5, default = 1sec */
+#define NXE2000_DEF_CHG_RAPID_RTIME			3		/* VAL(min) = 0: 120, 1: 180, 2: 240 3: 300, default = 300min */
+
+#define NXE2000_DEF_CHG_POWER_ON_VOL		4		/* VAL(V) = 0: 2.7 ~ 2.8, 1: 2.8 ~ 2.9, 2: 2.9 ~ 3.0, 3: 3.0 ~ 3.1, 4: 3.1 ~ 3.2, 5: 3.2 ~ 3.3, 6: 3.3 ~ 3.4, 7: 3.4 ~ 3.5 */
+													/* default(OTP) = 3.4 ~ 3.5V */
+#define NXE2000_DEF_CHG_VBATOV_SET			0		/* VAL(V) = 0: 3.95 ~ 4.38, 1: 4.10 ~ 4.53, default = 3.95 ~ 4.38V */
+#define NXE2000_DEF_CHG_VWEAK				1		/* VAL(V) = 0: 3.0 ~ 3.1, 1: 3.1 ~ 3.2, 2: 3.2 ~ 3.3, 3: 3.3 ~ 3.4, default(OTP) = 3.3 ~ 3.4V */
+#define NXE2000_DEF_CHG_VDEAD				0		/* VAL(V) = 0: 2.9 ~ 3.0, 1: 2.8 ~ 2.9, default(OTP) = 2.9 ~ 3.0V */
+#define NXE2000_DEF_CHG_VSHORT				1		/* VAL(V) = 0: 2.7 ~ 2.8, 1: 2.5 ~ 2.6, default(OTP) = 2.7 ~ 2.8V */
+
+#define NXE2000_DEF_CHG_VFCHG				3		/* VAL(V) = 0: 4.05, 1: 4.10, 2: 4.15, 3: 4.20,  4 ~ 7: 4.35, default = 4.10V */
+#define NXE2000_DEF_CHG_VRCHG				3		/* VAL(V) = 0: 3.85, 1: 3.90, 2: 3.95, 3: 4.00,  4 ~ 7: 4.10  default = 3.90V */
+
+#define NXE2000_DEF_CHG_CURR_ADP 			24		/* VAL(mA) = 100mA x (n + 1), MAX = 2500mA, default(OTP) = 2500mA */
+#define NXE2000_DEF_CHG_CURR_USB 			4		/* VAL(mA) = 100mA x (n + 1), MAX = 1500mA, default(OTP) = 500mA */
+#define NXE2000_DEF_CHG_CURR_RAPID_ADP		17		/* VAL(mA) = 100mA x (n + 1), MAX = 1800mA, default(OTP) = 100mA */
+#define NXE2000_DEF_CHG_CURR_RAPID_USB		5		/* VAL(mA) = 100mA x (n + 1), MAX = 1800mA, default(OTP) = 100mA */
+#define NXE2000_DEF_CHG_CURR_RAPID_COMP 	0		/* VAL(mA) = 50mA x (n + 1), MAX = 200mA, default = 50mA */
+
+#define NXE2000_DEF_DIE_RETURN_TEMP			0		/* VAL(C)= 0: 80, 1: 100, default(OTP) = 80' */
+#define NXE2000_DEF_DIE_ERROR_TEMP			0		/* VAL(C)= 0: 100, 1: 120 */
+#define NXE2000_DEF_DIE_SHUTDOWN_TEMP		1		/* VAL(C)= 0: 100, 1: 120, 2: 135, 3: 135, default(OTP) = 120'  */
+
+#define NXE2000_DEF_CHG_READY_CUR			0		/* VAL(mA)= 0:0(deefault), 1:10 */
+#define NXE2000_DEF_CHG_SUSPENDB			1
+
+/* REPCNT */
+#define	NXE2000_DEF_REPCNT_REPWRON			0
+#define	NXE2000_DEF_REPCNT_REPWRTIM			0
+#define	NXE2000_DEF_REPCNT_OFF_RESETO		0
+
+/* WATHDOG */
+#define	NXE2000_DEF_WATHDOG_WDOGTIM			3
+#define	NXE2000_DEF_WATHDOG_WDOG_EN			0
+#define	NXE2000_DEF_WATHDOG_WDOGSLPEN		0
+
+/* PWRIREN */
+#define	NXE2000_DEF_PWRIREN_WDOG			0
+#define	NXE2000_DEF_PWRIREN_NOE_OFF			0
+#define	NXE2000_DEF_PWRIREN_PWRON_OFF 		0
+#define	NXE2000_DEF_PWRIREN_PREOT			0
+#define	NXE2000_DEF_PWRIREN_PRVINDT			0
+#define	NXE2000_DEF_PWRIREN_EXTIN			0
+#define	NXE2000_DEF_PWRIREN_PWRON			0
+
+#define NXE2000_NUM_BUCK					5
+#define NXE2000_NUM_LDO						10
+#define NXE2000_NUM_PSO						5
+
+#define NXE2000_DEF_FET1CNT					0x05
+#define NXE2000_DEF_FET2CNT					0x00
+#define NXE2000_DEF_TSET					0x20
+#define NXE2000_DEF_CMPSET					0x00
+#define NXE2000_DEF_SUSPEND					0x01
+
+#endif  //#ifndef __NXE2000_POWER_H_
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/boards.cfg lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/boards.cfg
--- repo_avn/linux/bootloader/u-boot-2014.07/boards.cfg	2017-07-12 22:08:15.780987071 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/boards.cfg	2017-02-04 12:14:57.026930000 +0900
@@ -1231,5 +1231,6 @@
 Active  arm         slsiap	       s5p6818     s5p6818         avn_ref_bt          s5p6818_avn_ref_bt                    -
 Active  arm         slsiap	       s5p6818     s5p6818         avn_ref_bt          s5p6818_avn_ref_bt_linux              -
 Active  arm         slsiap	       s5p6818     s5p6818         avn_ref_bt          s5p6818_avn_ref_bt_linux_burning      -
+Active  arm         slsiap	       s5p6818     s5p6818         navi                s5p6818_navi                          -
 Active  aarch64		slsiap         s5p6818     s5p6818         svt                 s5p6818_arm64_svt                     s5p6818_arm64_svt:ARM64
 
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/common/cmd_mmc.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/common/cmd_mmc.c
--- repo_avn/linux/bootloader/u-boot-2014.07/common/cmd_mmc.c	2017-07-12 22:08:16.344986854 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/common/cmd_mmc.c	2017-02-27 22:07:51.777874000 +0900
@@ -10,6 +10,11 @@
 #include <mmc.h>
 
 static int curr_device = -1;
+
+#if defined(CONFIG_EMMC_SERIALNO)
+struct mmc *g_init_mmc = NULL;
+#endif
+
 #ifndef CONFIG_GENERIC_MMC
 int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -73,12 +78,52 @@
 
 static void print_mmcinfo(struct mmc *mmc)
 {
+#if defined(CONFIG_EMMC_SERIALNO)
+    char *args = NULL;
+#if defined(CONFIG_CMDLINE_TAG)
+    const char *serialno_prop = "androidboot.serialno";
+    char commandline_data[512];
+
+#if defined(CONFIG_BOOTARGS)
+    struct mmc *tmmc;
+    args = CONFIG_BOOTARGS;
+    printf("pre bootargs: %s\n", args);
+#endif
+#endif
+#endif
+
 	printf("Device: %s\n", mmc->cfg->name);
 	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
 	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
 	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
 			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
 			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
+#if defined(CONFIG_EMMC_SERIALNO)
+    printf("PSN: 0x%x, 0x%x, 0x%x, 0x%x \n", (mmc->cid[2] >> 8) & 0xff, (mmc->cid[2] & 0xff), (mmc->cid[3] >> 24) & 0xff, (mmc->cid[3] >> 16) & 0xff);
+    printf("Manufacturing date: 0x%x\n", (mmc->cid[3] >> 8) & 0xff);
+ 
+#if defined(CONFIG_CMDLINE_TAG)
+#if defined(CONFIG_BOOTARGS)
+    if(!(strstr(args, serialno_prop))){
+        printf("adding serialno\n");
+        if(g_init_mmc != NULL){
+            printf("ok mmc\n");
+            memset(commandline_data, 0x00, 512);
+            sprintf(commandline_data, "%s=%x%x%x%x%x %s", serialno_prop, (g_init_mmc->cid[2] >> 8) & 0xff, (g_init_mmc->cid[2] & 0xff), (g_init_mmc->cid[3] >> 24) & 0xff, (g_init_mmc->cid[3] >> 16) & 0xff, (g_init_mmc->cid[3] >> 8) & 0xff, args);
+            args = commandline_data;
+        }else{
+        }
+
+    }else{
+        printf("serialno is exist\n");
+    }
+
+        printf("post bootargs: %s\n", args);
+#else
+        printf("bootargs is null\n");
+#endif
+#endif
+#endif
 
 	printf("Tran Speed: %d\n", mmc->tran_speed);
 	printf("Rd Block Len: %d\n", mmc->read_bl_len);
@@ -104,6 +149,10 @@
 		mmc->has_init = 0;
 	if (mmc_init(mmc))
 		return NULL;
+    
+#if defined(CONFIG_EMMC_SERIALNO)
+    g_init_mmc = mmc;
+#endif
 	return mmc;
 }
 static int do_mmcinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/common/main.c lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/common/main.c
--- repo_avn/linux/bootloader/u-boot-2014.07/common/main.c	2017-07-12 22:08:16.364986847 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/common/main.c	2017-02-10 15:49:03.640648000 +0900
@@ -85,5 +85,8 @@
 
 	autoboot_command(s);
 
+#ifdef	CONFIG_MACH_S5P6818
+	att_watchdog_disable();
+#endif
 	cli_loop();
 }
diff -urN '--exclude=.git' '--exclude=.gitignore' repo_avn/linux/bootloader/u-boot-2014.07/include/configs/s5p6818_navi.h lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/include/configs/s5p6818_navi.h
--- repo_avn/linux/bootloader/u-boot-2014.07/include/configs/s5p6818_navi.h	1970-01-01 09:00:00.000000000 +0900
+++ lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/lollipop-5.1.1_r6-avn-release_3rd_k1707171.0.0.39/linux/bootloader/u-boot-2014.07/include/configs/s5p6818_navi.h	2017-04-17 10:34:06.476300000 +0900
@@ -0,0 +1,703 @@
+/*
+ * (C) Copyright 2009 Nexell Co.,
+ * jung hyun kim<jhkim@nexell.co.kr>
+ *
+ * Configuation settings for the Nexell board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H__
+#define __CONFIG_H__
+
+/*-----------------------------------------------------------------------
+ * soc headers
+ */
+#ifndef	__ASM_STUB_PROCESSOR_H__
+#include <platform.h>
+#endif
+
+/*-----------------------------------------------------------------------
+ *  u-boot-2014.07
+ */
+#define CONFIG_SYS_LDSCRIPT "arch/arm/cpu/slsiap/u-boot.lds"
+#define CONFIG_SYS_GENERIC_BOARD
+
+#define	CONFIG_MACH_S5P6818
+#define CONFIG_MACH_S5P6818_NAVI
+
+/*-----------------------------------------------------------------------
+ *  FIT
+ */
+#if 0
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE
+#define CONFIG_FIT_SIGNATURE
+#if defined(CONFIG_FIT_SIGNATURE)
+#define CONFIG_RSA
+#define	CONFIG_OF_CONTROL
+#endif
+#endif
+
+/*-----------------------------------------------------------------------
+ *  System memory Configuration
+ */
+#define CONFIG_RELOC_TO_TEXT_BASE												/* Relocate u-boot code to TEXT_BASE */
+
+#define	CONFIG_SYS_TEXT_BASE 			0x43C00000
+#define	CONFIG_SYS_INIT_SP_ADDR			CONFIG_SYS_TEXT_BASE					/* init and run stack pointer */
+
+/* malloc() pool */
+#define	CONFIG_MEM_MALLOC_START			0x44000000
+#define CONFIG_MEM_MALLOC_LENGTH		32*1024*1024							/* more than 2M for ubifs: MAX 16M */
+
+/* when CONFIG_LCD */
+#define CONFIG_FB_ADDR					0x46000000
+#define CONFIG_BMP_ADDR					0x47000000
+
+/* Download OFFSET */
+#define CONFIG_MEM_LOAD_ADDR			0x48000000
+
+/*-----------------------------------------------------------------------
+ *  High Level System Configuration
+ */
+#undef  CONFIG_USE_IRQ		     												/* Not used: not need IRQ/FIQ stuff	*/
+#define CONFIG_SYS_HZ	   				1000									/* decrementer freq: 1ms ticks */
+
+#define	CONFIG_SYS_SDRAM_BASE			CFG_MEM_PHY_SYSTEM_BASE					/* board_init_f */
+#define	CONFIG_SYS_SDRAM_SIZE			CFG_MEM_PHY_SYSTEM_SIZE
+
+#define CONFIG_NR_DRAM_BANKS	   		1										/* dram 1 bank num */
+
+#define	CONFIG_SYS_MALLOC_END			(CONFIG_MEM_MALLOC_START + CONFIG_MEM_MALLOC_LENGTH)	/* relocate_code and  board_init_r */
+#define CONFIG_SYS_MALLOC_LEN			(CONFIG_MEM_MALLOC_LENGTH - 0x8000)						/* board_init_f, more than 2M for ubifs */
+
+#define CONFIG_SYS_LOAD_ADDR			CONFIG_MEM_LOAD_ADDR					/* kernel load address */
+
+#define CONFIG_SYS_MEMTEST_START		CONFIG_SYS_MALLOC_END					/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END			(CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE)
+
+/*-----------------------------------------------------------------------
+ *  System initialize options (board_init_f)
+ */
+#define CONFIG_ARCH_CPU_INIT													/* board_init_f->init_sequence, call arch_cpu_init */
+#define	CONFIG_BOARD_EARLY_INIT_F												/* board_init_f->init_sequence, call board_early_init_f */
+#define	CONFIG_BOARD_LATE_INIT													/* board_init_r, call board_early_init_f */
+//#define	CONFIG_DISPLAY_CPUINFO													[> board_init_f->init_sequence, call print_cpuinfo <]
+#define	CONFIG_SYS_DCACHE_OFF													/* board_init_f, CONFIG_SYS_ICACHE_OFF */
+//#define	CONFIG_ARCH_MISC_INIT													[> board_init_r, call arch_misc_init <]
+//#define	CONFIG_SYS_ICACHE_OFF
+
+#define CONFIG_MMU_ENABLE
+#ifdef  CONFIG_MMU_ENABLE
+#undef  CONFIG_SYS_DCACHE_OFF
+#endif
+
+/*-----------------------------------------------------------------------
+ *	U-Boot default cmd
+ */
+//#define CONFIG_CMD_MEMORY   [> md mm nm mw cp cmp crc base loop mtest <]
+//#define CONFIG_CMD_NET      /* bootp, tftpboot, rarpboot    */
+//#define CONFIG_CMD_RUN      [> run command in env variable  <]
+#define CONFIG_CMD_SAVEENV  /* saveenv          */
+//#define CONFIG_CMD_SOURCE   [> "source" command support <]
+#define CONFIG_CMD_BOOTD	/* "boot" command support */
+//#define	CONFIG_CMD_MEMTEST
+
+/*-----------------------------------------------------------------------
+ *	U-Boot Environments
+ */
+/* refer to common/env_common.c	*/
+#define CONFIG_BOOTDELAY	   			0
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+//#define CONFIG_ETHADDR		   			00:e2:1c:ba:e8:60
+//#define CONFIG_NETMASK		   			255.255.255.0
+//#define CONFIG_IPADDR					192.168.1.165
+//#define CONFIG_SERVERIP					192.168.1.164
+//#define CONFIG_GATEWAYIP				192.168.1.254
+//#define CONFIG_BOOTFILE					"uImage"  		[> File to load	<]
+
+#define CONFIG_BOOTCOMMAND "ext4load mmc 2:1 0x40008000 Image;ext4load mmc 2:1 0x49000000 root.img.gz;goimage 0x40008000"
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_PROMPT				"s5p6818# "     									/* Monitor Command Prompt   */
+#define CONFIG_SYS_LONGHELP				       												/* undef to save memory	   */
+#define CONFIG_SYS_CBSIZE		   		1024		   											/* Console I/O Buffer Size  */
+#define CONFIG_SYS_PBSIZE		   		(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) 	/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS			   	16		       										/* max number of command args   */
+#define CONFIG_SYS_BARGSIZE			   	CONFIG_SYS_CBSIZE	       							/* Boot Argument Buffer Size    */
+
+/*-----------------------------------------------------------------------
+ * allow to overwrite serial and ethaddr
+ */
+#define CONFIG_ENV_OVERWRITE
+//#define CONFIG_SYS_HUSH_PARSER			[> use "hush" command parser	<]
+#ifdef 	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#endif
+
+/*-----------------------------------------------------------------------
+ * Etc Command definition
+ */
+//#define	CONFIG_CMD_BDI					[> board info	<]
+//#define	CONFIG_CMD_IMI					[> image info	<]
+//#define	CONFIG_CMD_MEMORY
+#define	CONFIG_CMD_RUN					/* run commands in an environment variable	*/
+#define CONFIG_CMDLINE_EDITING			/* add command line history	*/
+#define	CONFIG_CMDLINE_TAG				/* use bootargs commandline */
+//#define CONFIG_SETUP_MEMORY_TAGS
+//#define CONFIG_INITRD_TAG
+//#define CONFIG_SERIAL_TAG
+//#define CONFIG_REVISION_TAG
+
+#undef	CONFIG_BOOTM_NETBSD
+#undef	CONFIG_BOOTM_RTEMS
+#undef  CONFIG_BOOTM_VXWORKS
+#undef  CONFIG_CMD_IMPORTENV
+#undef  CONFIG_CMD_EXPORTENV
+// #undef	CONFIG_GZIP
+
+/*-----------------------------------------------------------------------
+ * serial console configuration
+ */
+#define CONFIG_S5P_SERIAL
+#define CONFIG_S5P_SERIAL_INDEX			CFG_UART_DEBUG_CH
+#define CONFIG_S5P_SERIAL_CLOCK			CFG_UART_CLKGEN_CLOCK_HZ
+
+#define CONFIG_BAUDRATE		   			CFG_UART_DEBUG_BAUDRATE
+#define CONFIG_SYS_BAUDRATE_TABLE	   	{ 9600, 19200, 38400, 57600, 115200 }
+#define CONFIG_S5P_SERIAL_FLUSH_ON_INIT
+
+/*-----------------------------------------------------------------------
+ * Ethernet configuration
+ * depend on CONFIG_CMD_NET
+ */
+//#define CONFIG_DRIVER_DM9000			1
+
+#if defined(CONFIG_CMD_NET)
+	/* DM9000 Ethernet device */
+	#if defined(CONFIG_DRIVER_DM9000)
+	#define CONFIG_DM9000_BASE	   		CFG_ETHER_EXT_PHY_BASEADDR		/* DM9000: 0x04000000(CS1) */
+	#define DM9000_IO	   				CONFIG_DM9000_BASE
+	#define DM9000_DATA	   				(CONFIG_DM9000_BASE + 0x4)
+//	#define CONFIG_DM9000_DEBUG
+	#endif
+	#define CONFIG_CMD_PING
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH
+ */
+//#define CONFIG_CMD_NAND
+//#define CONFIG_ENV_IS_IN_NAND
+
+#if defined(CONFIG_CMD_NAND)
+	#define CONFIG_SYS_MAX_NAND_DEVICE		(1)
+	#define CONFIG_SYS_NAND_MAX_CHIPS   	(1)
+	#define CONFIG_SYS_NAND_BASE		   	PHY_BASEADDR_CS_NAND							/* Nand data register, nand->IO_ADDR_R/_W */
+	#define CONFIG_SYS_NAND_ONFI_DETECTION
+	#define CONFIG_CMD_NAND_TRIMFFS
+
+	#define	CONFIG_MTD_NAND_NXP
+//	#define	CONFIG_MTD_NAND_ECC_BCH															/* sync kernel config */
+	#define	CONFIG_MTD_NAND_ECC_HW
+//	#define	CONFIG_MTD_NAND_VERIFY_WRITE
+//	#define	CONFIG_MTD_NAND_BMT_FIRST_LAST													/* Samsumg 8192 page nand write bad mark on 1st and last block */
+
+	#define CONFIG_CMD_UPDATE_NAND
+
+	#if defined (CONFIG_MTD_NAND_ECC_BCH)
+		#define	CONFIG_BCH
+		#define	CONFIG_NAND_ECC_BCH
+	#endif
+
+	#if defined(CONFIG_ENV_IS_IN_NAND)
+		#define	CONFIG_ENV_OFFSET			(0x400000)									/* 4MB */
+		#define CONFIG_ENV_SIZE           	(0x100000)									/* 1 block size */
+		#define CONFIG_ENV_RANGE			(0x400000)		 							/* avoid bad block */
+	#endif
+
+	#undef  CONFIG_CMD_IMLS
+
+	#define	CONFIG_CMD_MTDPARTS
+	#if defined(CONFIG_CMD_MTDPARTS)
+		#define	CONFIG_MTD_DEVICE
+		#define	CONFIG_MTD_PARTITIONS
+		#define MTDIDS_DEFAULT				"nand0=mtd-nand"
+		#define MTDPARTS_DEFAULT			"mtdparts=mtd-nand:2m(u-boot),4m(kernel),8m(ramdisk),-(extra)"
+	#endif
+
+//	#define CONFIG_MTD_DEBUG
+	#ifdef  CONFIG_MTD_DEBUG
+		#define CONFIG_MTD_DEBUG_VERBOSE	0	/* For nand debug message = 0 ~ 3 *//* list all images found in flash	*/
+	#endif
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH
+ */
+#define	CONFIG_SYS_NO_FLASH
+
+
+/*-----------------------------------------------------------------------
+ * EEPROM
+ */
+
+//#define CONFIG_CMD_EEPROM
+//#define CONFIG_SPI								/* SPI EEPROM, not I2C EEPROM */
+//#define CONFIG_ENV_IS_IN_EEPROM
+
+#if defined(CONFIG_CMD_EEPROM)
+
+	#if defined(CONFIG_SPI)
+ 		#define CONFIG_SPI_MODULE_0
+ 		#define CONFIG_SPI0_TYPE				1 /* 1: EEPROM, 0: SPI device */
+ 		#define CONFIG_EEPROM_SPI_MODULE_NUM	0
+
+		#define CONFIG_EEPROM_ERASE_SIZE		32*1024
+		#define CONFIG_EEPROM_WRITE_PAGE_SIZE	256
+		#define CONFIG_EEPROM_ADDRESS_STEP		3
+
+		#define CMD_SPI_WREN			0x06		// Set Write Enable Latch
+		#define CMD_SPI_WRDI			0x04		// Reset Write Enable Latch
+		#define CMD_SPI_RDSR			0x05		// Read Status Register
+		#define CMD_SPI_WRSR			0x01		// Write Status Register
+		#define CMD_SPI_READ			0x03		// Read Data from Memory Array
+		#define CMD_SPI_WRITE			0x02		// Write Data to Memory Array
+
+		#define CMD_SPI_SE				0x52		// Sector Erase
+		#define CMD_SPI_BE				0xC7		// Bulk Erase
+		#define CMD_SPI_DP				0xB9		// Deep Power-down
+		#define CMD_SPI_RES				0xAB		// Release from Deep Power-down
+
+		#define CONFIG_SPI_EEPROM_WRITE_PROTECT
+		#if defined(CONFIG_SPI_EEPROM_WRITE_PROTECT)
+			#define	CONFIG_SPI_EEPROM_WP_PAD 			CFG_IO_SPI_EEPROM_WP
+			#define	CONFIG_SPI_EEPROM_WP_ALT			CFG_IO_SPI_EEPROM_WP_ALT
+		#endif
+
+ 	 	#define CONFIG_CMD_SPI_EEPROM_UPDATE
+ 	 	#if defined (CONFIG_CMD_SPI_EEPROM_UPDATE)
+ 		/*
+ 	  	 *	EEPROM Environment Organization
+ 	 	 *	[Note R/W unit 64K]
+ 	 	 *
+		 *    0 ~   16K Second Boot [NSIH + Sencond boot]
+		 *   16 ~   32K Reserved
+		 *   32 ~   64K Enviroment
+		 *   64 ~  512K U-Boot
+ 	 	 */
+			#define	CONFIG_2STBOOT_OFFSET			   	0
+			#define	CONFIG_2STBOOT_SIZE				   	16*1024
+			#define	CONFIG_UBOOT_OFFSET				   	64*1024
+			#define	CONFIG_UBOOT_SIZE					(4096-64)*1024
+ 	 	#endif
+		#if defined(CONFIG_ENV_IS_IN_EEPROM)
+			#define	CONFIG_ENV_OFFSET					32*1024	/* 248 ~ 256K Environment */
+			#define CONFIG_ENV_SIZE						32*1024
+			#define CONFIG_ENV_RANGE					CONFIG_ENV_SIZE
+			#define CONFIG_SYS_DEF_EEPROM_ADDR			0					/* Need 0, when SPI */
+			#define CONFIG_SYS_I2C_FRAM									/* To avoid max length limit when spi write */
+			//#define DEBUG_ENV
+		#endif
+	#endif
+#endif
+
+/*-----------------------------------------------------------------------
+ * SPI
+ */
+
+#if defined  (CONFIG_SPI)
+    #if defined (CONFIG_SPI_MODULE_0)
+		#define CONFIG_SPI_MODULE_0_SOURCE_CLOCK    CFG_SPI0_SRC_CLK
+        #define CONFIG_SPI_MODULE_0_CLOCK           CFG_SPI0_OUT_CLK
+        #define CONFIG_SPI_MODULE_0_EEPROM          CONFIG_SPI0_TYPE    /* 1: EEPROM, 0: SPI device */
+    #endif
+    #if defined (CONFIG_SPI_MODULE_1)
+		#define CONFIG_SPI_MODULE_1_SOURCE_CLOCK    CFG_SPI1_SRC_CLK
+        #define CONFIG_SPI_MODULE_1_CLOCK           CFG_SPI0_OUT_CLK
+        #define CONFIG_SPI_MODULE_1_EEPROM          CONFIG_SPI1_TYPE    /* 1: EEPROM, 0: SPI device */
+    #endif
+    #if defined (CONFIG_SPI_MODULE_2)
+		#define CONFIG_SPI_MODULE_2_SOURCE_CLOCK    CFG_SPI2_SRC_CLK
+        #define CONFIG_SPI_MODULE_2_CLOCK           CFG_SPI0_OUT_CLK
+        #define CONFIG_SPI_MODULE_2_EEPROM          CONFIG_SPI2_TYPE    /* 1: EEPROM, 0: SPI device */
+    #endif
+#endif
+
+/*-----------------------------------------------------------------------
+ * USB Host / Gadget
+ *
+ * command
+ *
+ * #> usb start
+ * #> fatls   usb 0 "directory"
+ * #> fatload usb 0  0x.....	"file"
+ */
+//#define CONFIG_CMD_USB
+#if defined(CONFIG_CMD_USB)
+	#define CONFIG_USB_HUB_USB2514
+	#define CONFIG_USB_EHCI_SYNOPSYS
+	#define CONFIG_USB_EHCI_MODE
+	#define CONFIG_CMD_UPDATE_USBHOST
+	#define CONFIG_USB_STORAGE
+	#define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS 3
+#endif
+
+/* Gadget */
+#define	CONFIG_USB_GADGET
+#if defined(CONFIG_USB_GADGET)
+	#define CONFIG_NXP_USBDOWN
+	#define CONFIG_NXP_DWC_OTG
+	#define CONFIG_NXP_DWC_OTG_PHY
+	//#define CONFIG_NXP_DWC_OTG_HCD
+	//#define CONFIG_CMD_UPDATE_OTGHOST
+#endif
+
+#if defined(CONFIG_USB_EHCI_SYNOPSYS) && (defined(CONFIG_NXP_DWC_OTG_HCD))
+#error Disable 'CONFIG_NXP_DWC_OTG_HCD', if 'CONFIG_USB_EHCI_SYNOPSYS' is enabled
+#endif
+/*-----------------------------------------------------------------------
+ * PMIC
+ */
+
+#define CONFIG_PMIC
+	#if defined(CONFIG_PMIC)
+		#define CONFIG_CMD_I2C
+		#define CONFIG_PMIC_I2C
+		#define CONFIG_PMIC_I2C_BUS							I2C_7
+
+		#define CONFIG_POWER
+		#define CONFIG_POWER_I2C
+
+		#define CONFIG_PMIC_NXE2000
+	#endif
+
+	#if defined(CONFIG_PMIC_NXE2000)
+		#define CONFIG_POWER_NXE2000
+
+		//#define CONFIG_ENABLE_INIT_VOLTAGE						/* enable set voltage(ARM, CORE)  */
+		//#define CONFIG_PMIC_REG_DUMP
+	#endif
+
+/*-----------------------------------------------------------------------
+ * I2C
+ *
+ * probe
+ * 	#> i2c probe
+ *
+ * speed
+ * 	#> i2c speed xxxxxx
+ *
+ * select bus
+ * 	#> i2c dev n
+ *
+ * write
+ * 	#> i2c mw 0x30 0xRR 0xDD 1
+ *	- 0x30 = slave, 0xRR = register, 0xDD = data, 1 = write length
+ *
+ * read
+ * 	#> i2c md 0x30 0xRR 1
+ *	- 0x30 = slave, 0xRR = register, 1 = read length
+ *
+ */
+#define	CONFIG_CMD_I2C
+#if defined(CONFIG_CMD_I2C)
+	#define	CONFIG_HARD_I2C
+	#define CONFIG_I2C_MULTI_BUS
+
+	#define CONFIG_I2C_GPIO_MODE							/* gpio i2c */
+	#define	CONFIG_SYS_I2C_SPEED		100000				/* default speed, 100 khz */
+
+	#define	CONFIG_I2C0_NEXELL								/* 0 = i2c 0 */
+	#define	CONFIG_I2C0_NO_STOP				0				/* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+	#define	CONFIG_I2C1_NEXELL								/* 1 = i2c 1 */
+	#define	CONFIG_I2C1_NO_STOP				0				/* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+	#define	CONFIG_I2C2_NEXELL								/* 1 = i2c 2 */
+	#define	CONFIG_I2C2_NO_STOP				0				/* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+    #define CONFIG_I2C3_NEXELL                              /* 1 = i2c 3 */
+    #define CONFIG_I2C3_NO_STOP             0               /* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+    #define CONFIG_I2C4_NEXELL                              /* 1 = i2c 4 */
+    #define CONFIG_I2C4_NO_STOP             0               /* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+    #define CONFIG_I2C5_NEXELL                              /* 1 = i2c 5 */
+    #define CONFIG_I2C5_NO_STOP             0               /* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+    #define CONFIG_I2C6_NEXELL                              /* 1 = i2c 6 */
+    #define CONFIG_I2C6_NO_STOP             0               /* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+	#define CONFIG_I2C7_NEXELL                              /* 1 = i2c 7 */
+    #define CONFIG_I2C7_NO_STOP             1               /* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+    #define CONFIG_I2C8_NEXELL                              /* 1 = i2c 8 */
+    #define CONFIG_I2C8_NO_STOP             0               /* when tx end, 0= generate stop signal , 1: skip stop signal */
+
+    #define CFG_IO_I2C0_SCL					((PAD_GPIO_B + 18) | PAD_FUNC_ALT2)	//AP_GPB18_MDEC_HDCAM_HMRX_AUDIO2SCL
+    #define CFG_IO_I2C0_SDA					((PAD_GPIO_B + 16) | PAD_FUNC_ALT2)	//AP_GPB16_MDEC_HDCAM_HMRX_AUDIO2SDA
+
+    #define CFG_IO_I2C1_SCL					((PAD_GPIO_C + 1) | PAD_FUNC_ALT1)	//AP_GPC1_SECSCL
+    #define CFG_IO_I2C1_SDA					((PAD_GPIO_C + 2) | PAD_FUNC_ALT1)	//AP_GPC2_SECSDA
+
+    #define CFG_IO_I2C2_SCL					((PAD_GPIO_C + 25) | PAD_FUNC_ALT1)	// AP_GPC25_TW9900_CS4955_HUBSCL
+    #define CFG_IO_I2C2_SDA					((PAD_GPIO_C + 27) | PAD_FUNC_ALT1)	// AP_GPC27_TW9900_CS4955_HUBSDA
+
+    #define CFG_IO_I2C3_SCL					((PAD_GPIO_D + 4) | PAD_FUNC_ALT0)	// AP_GPD4_DMB_AUD1_APLSCL
+    #define CFG_IO_I2C3_SDA					((PAD_GPIO_D + 5) | PAD_FUNC_ALT0)	// AP_GPD5_DMB_AUD1_APLSDA
+
+    #define CFG_IO_I2C4_SCL					((PAD_GPIO_D + 6) | PAD_FUNC_ALT0)	// AP_GPD6_TOUCH_BTSCL
+    #define CFG_IO_I2C4_SDA					((PAD_GPIO_D + 7) | PAD_FUNC_ALT0)	// AP_GPD7_TOUCH_BTSDA
+
+    #define CFG_IO_I2C5_SCL             ((PAD_GPIO_D + 22) | PAD_FUNC_ALT0)
+    #define CFG_IO_I2C5_SDA             ((PAD_GPIO_D + 23) | PAD_FUNC_ALT0)
+
+    #define CFG_IO_I2C6_SCL             ((PAD_GPIO_D + 26) | PAD_FUNC_ALT0)
+    #define CFG_IO_I2C6_SDA             ((PAD_GPIO_D + 27) | PAD_FUNC_ALT0)
+    
+	#define CFG_IO_I2C7_SCL             ((PAD_GPIO_E + 9) | PAD_FUNC_ALT0)
+    #define CFG_IO_I2C7_SDA             ((PAD_GPIO_E + 8) | PAD_FUNC_ALT0)
+
+    #define CFG_IO_I2C8_SCL             ((PAD_GPIO_D + 4) | PAD_FUNC_ALT0)	// I2C1 SCL used as I2C_GPIO8 SCL
+    #define CFG_IO_I2C8_SDA             ((PAD_GPIO_D + 5) | PAD_FUNC_ALT0)	// I2C1 SDA used as I2C_GPIO8 SDA
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * SD/MMC
+ * 	#> mmcinfo			-> get current device mmc info or detect mmc device
+ * 	#> mmc rescan		-> rescan mmc device
+ * 	#> mmc dev 'num'	-> set current sdhc device for mmcinfo or mmc rescan
+ * 						  (ex. "mmc dev 0" or "mmc dev 1")
+ *
+ * #> fatls   mmc 0 "directory"
+ * #> fatload mmc 0  0x.....	"file"
+ *
+ */
+#define	CONFIG_CMD_MMC
+#define CONFIG_ENV_IS_IN_MMC
+
+#if defined(CONFIG_CMD_MMC)
+
+	#define	CONFIG_MMC
+	#define CONFIG_GENERIC_MMC
+	#define HAVE_BLOCK_DEVICE
+
+	#define CONFIG_MMC0_ATTACH      	TRUE    /* 0 = MMC0 : External 	 */
+	#define CONFIG_MMC1_ATTACH      	FALSE   /* 1 = MMC1 : 	         */
+	#define CONFIG_MMC2_ATTACH      	TRUE    /* 2 = MMC2 : BOOT(eMMC) */
+
+	#define CONFIG_MMC0_CLOCK			50000000
+	#define CONFIG_MMC0_CLK_DELAY       DW_MMC_DRIVE_DELAY(0) | DW_MMC_SAMPLE_DELAY(0) | DW_MMC_DRIVE_PHASE(2)| DW_MMC_SAMPLE_PHASE(1)
+
+	#define CONFIG_MMC2_CLOCK			50000000
+	#define CONFIG_MMC2_CLK_DELAY       DW_MMC_DRIVE_DELAY(0) | DW_MMC_SAMPLE_DELAY(0) | DW_MMC_DRIVE_PHASE(2)| DW_MMC_SAMPLE_PHASE(1)
+	#define CONFIG_MMC2_BUS_WIDTH       8
+    #define CONFIG_MMC2_TRANS_MODE      0 //1 : DDR_MODE, 0: SDR_MODE
+
+	#define CONFIG_DWMMC
+	#define CONFIG_NXP_DWMMC
+	#define CONFIG_MMC_PARTITIONS
+	#define CONFIG_CMD_MMC_UPDATE
+	//#define CONFIG_CMD_UPDATE_SDCARD
+	#define CONFIG_SYS_MMC_BOOT_DEV  	(2)		/* BOOT MMC DEVICE NUM */
+
+	#if defined(CONFIG_ENV_IS_IN_MMC)
+	#define CONFIG_ENV_OFFSET           476*1024                        /* 0x00077000*/
+	#define CONFIG_ENV_SIZE           	32*1024					/* N block size (512Byte Per Block)  */
+	#define CONFIG_ENV_RANGE			CONFIG_ENV_SIZE * 2 	/* avoid bad block */
+	#define CONFIG_SYS_MMC_ENV_DEV  	CONFIG_SYS_MMC_BOOT_DEV
+	#endif
+#endif
+
+/*-----------------------------------------------------------------------
+ *	GPIO LIBRARY
+ */
+#define CONFIG_GPIOLIB_NXP
+
+/*-----------------------------------------------------------------------
+ * Default environment organization
+ */
+#if !defined(CONFIG_ENV_IS_IN_MMC) && !defined(CONFIG_ENV_IS_IN_NAND) &&	\
+	!defined(CONFIG_ENV_IS_IN_FLASH) && !defined(CONFIG_ENV_IS_IN_EEPROM)
+	#define CONFIG_ENV_IS_NOWHERE						/* default: CONFIG_ENV_IS_NOWHERE */
+	#define	CONFIG_ENV_OFFSET			  	  1024
+	#define CONFIG_ENV_SIZE           		4*1024		/* env size */
+	#undef	CONFIG_CMD_IMLS								/* imls - list all images found in flash, default enable so disable */
+#endif
+
+/*-----------------------------------------------------------------------
+ * FAT Partition
+ */
+#if defined(CONFIG_MMC) || defined(CONFIG_CMD_USB)
+	#define CONFIG_DOS_PARTITION
+
+	#define CONFIG_CMD_FAT
+	#define CONFIG_FS_FAT
+	#define CONFIG_FAT_WRITE
+
+	#define CONFIG_CMD_EXT4
+	#define CONFIG_CMD_EXT4_WRITE
+	#define CONFIG_FS_EXT4
+	#define CONFIG_EXT4_WRITE
+#endif
+
+/*-----------------------------------------------------------------------
+ * UBIFS Partition
+ * #>ubi part extra
+ * #>ubi info
+ * #>ubi info l
+ * #>ubifsmount extra
+ * #>ubifsls
+ */
+//#define CONFIG_CMD_UBIFS
+
+#if defined(CONFIG_CMD_UBIFS)
+	#define CONFIG_RBTREE
+	#define	CONFIG_CMD_UBI
+	#define	CONFIG_LZO
+
+	//#define	CONFIG_UBIFS_FS_DEBUG
+	#if defined(CONFIG_UBIFS_FS_DEBUG)
+	#define	CONFIG_UBIFS_FS_DEBUG_MSG_LVL	1	/* For ubifs debug message = 0 ~ 3 */
+	#endif
+#endif
+
+/*-----------------------------------------------------------------------
+ * FASTBOOT
+ */
+#define CONFIG_FASTBOOT
+
+#if defined(CONFIG_FASTBOOT) & defined(CONFIG_USB_GADGET)
+#define CFG_FASTBOOT_TRANSFER_BUFFER        CONFIG_MEM_LOAD_ADDR
+#define CFG_FASTBOOT_TRANSFER_BUFFER_OFFSET \
+	(CONFIG_MEM_LOAD_ADDR - CFG_MEM_PHY_SYSTEM_BASE)
+#define CFG_FASTBOOT_TRANSFER_BUFFER_SIZE \
+	(CFG_MEM_PHY_SYSTEM_SIZE - CFG_FASTBOOT_TRANSFER_BUFFER_OFFSET)
+
+#define FASTBOOT_PARTS_DEFAULT      \
+    "flash=mmc,2:2ndboot:2nd:0x200,0xFD00;"     \
+    "flash=mmc,2:bootloader1:boot:0x10000,0x77000;"     \
+    "flash=mmc,2:bootloader2:boot:0x88000,0x77000;"     \
+    "flash=mmc,2:boot:ext4:0x00100000,0x04000000;"      \
+    "flash=mmc,2:system:ext4:0x04100000,0x2F200000;"    \
+    "flash=mmc,2:cache:ext4:0x33300000,0x1AC00000;"     \
+    "flash=mmc,2:misc:ext4:0x4E000000,0x00800000;"      \
+    "flash=mmc,2:recovery:ext4:0x4E900000,0x01600000;"  \
+    "flash=mmc,2:userdata:ext4:0x50000000,0x0;"
+#endif
+
+/*-----------------------------------------------------------------------
+ * Logo command
+ */
+#define CONFIG_DISPLAY_OUT
+
+#define CONFIG_LOGO_DEVICE_MMC
+
+#if defined(CONFIG_LOGO_DEVICE_MMC) && defined(CONFIG_LOGO_DEVICE_NAND)
+#error "Duplicated config for logo device!!!"
+#endif
+
+#if	defined(CONFIG_DISPLAY_OUT)
+	#define	CONFIG_PWM			/* backlight */
+	/* display out device */
+	#define	CONFIG_DISPLAY_OUT_LVDS
+    //#define	CONFIG_DISPLAY_OUT_HDMI
+
+	/* display logo */
+	#define CONFIG_LOGO_NEXELL				/* Draw loaded bmp file to FB or fill FB */
+//	#define CONFIG_CMD_LOGO_LOAD
+
+	/* Logo command: board.c */
+	#if defined(CONFIG_LOGO_DEVICE_NAND)
+	/* From NAND */
+    #define CONFIG_CMD_LOGO_WALLPAPERS "ext4load mmc 2:1 0x47000000 logo.bmp; drawbmp 0x47000000"
+    #define CONFIG_CMD_LOGO_BATTERY "ext4load mmc 2:1 0x47000000 battery.bmp; drawbmp 0x47000000"
+    #define CONFIG_CMD_LOGO_UPDATE "ext4load mmc 2:1 0x47000000 update.bmp; drawbmp 0x47000000"
+	#define CONFIG_CMD_LOGO_BOOT_MENU_1 "ext4load mmc 2:1 0x47000000 boot_menu_1.bmp; drawbmp 0x47000000"
+	#define CONFIG_CMD_LOGO_BOOT_MENU_2 "ext4load mmc 2:1 0x47000000 boot_menu_2.bmp; drawbmp 0x47000000"
+	//#define CONFIG_CMD_LOGO_BOOT_MENU_3 "ext4load mmc 2:1 0x47000000 boot_menu_3.bmp; drawbmp 0x47000000"
+	#else
+	/* From MMC */
+    #define CONFIG_CMD_LOGO_WALLPAPERS "ext4load mmc 2:6 0x47000000 logo.bmp; drawbmp 0x47000000"
+    #define CONFIG_CMD_LOGO_BATTERY "ext4load mmc 2:6 0x47000000 battery.bmp; drawbmp 0x47000000"
+    #define CONFIG_CMD_LOGO_UPDATE "ext4load mmc 2:6 0x47000000 update.bmp; drawbmp 0x47000000"
+    
+    #define CONFIG_CMD_LOGO_WALLPAPERS_NORMAL "ext4load mmc 2:1 0x47000000 logo.bmp; drawbmp 0x47000000"
+    #define CONFIG_CMD_LOGO_BATTERY_NORMAL "ext4load mmc 2:1 0x47000000 battery.bmp; drawbmp 0x47000000"
+    #define CONFIG_CMD_LOGO_UPDATE_NORMAL "ext4load mmc 2:1 0x47000000 update.bmp; drawbmp 0x47000000"
+	#define CONFIG_CMD_LOGO_BOOT_MENU_1 "ext4load mmc 2:1 0x47000000 boot_menu_1.bmp; drawbmp 0x47000000"
+	#define CONFIG_CMD_LOGO_BOOT_MENU_2 "ext4load mmc 2:1 0x47000000 boot_menu_2.bmp; drawbmp 0x47000000"
+	//#define CONFIG_CMD_LOGO_BOOT_MENU_3 "ext4load mmc 2:1 0x47000000 boot_menu_3.bmp; drawbmp 0x47000000"
+	#endif
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Recover boot
+ */
+#define	CONFIG_RECOVERY_BOOT
+#if defined (CONFIG_RECOVERY_BOOT)
+	#define CONFIG_CMD_RECOVERY_BOOT "setenv bootargs console=ttySAC3,115200n8 androidboot.hardware=s5p6818_navi androidboot.console=ttySAC3 androidboot.serialno=12345 initrd=0x49000000,0x200000 init=/init;ext4load mmc 2:6 0x48000000 uImage;ext4load mmc 2:6 0x49000000 ramdisk-recovery.img;bootm 0x48000000"
+#endif
+
+#define        CONFIG_UPDATE_BOOT
+#if defined (CONFIG_UPDATE_BOOT)
+    #define CONFIG_CMD_UPDATE_BOOT "setenv bootargs console=ttySAC3,115200n8 root=/dev/ram0 rw initrd=0x49000000,32M ramdisk=32768;ext4load mmc 2:1 0x48000000 uImage_update;ext4load mmc 2:1 0x49000000 ramdisk_update.gz;bootm 0x48000000"
+#endif
+
+
+#define CONFIG_SILENT_CONSOLE
+#define CONFIG_SYS_CONSOLE_INFO_QUIET	/* print u-boot logo */
+#ifdef CONFIG_SILENT_CONSOLE
+#define CONFIG_SILENT_U_BOOT_ONLY		/* for bootm command, if not defined fail bootm command */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Watchdog
+ */
+
+/* Enable the HW watchdog, since we can use this with bootcount */
+#define CONFIG_HW_WATCHDOG
+#define CONFIG_WATCHDOG_TIMEOUT	10
+
+/*-----------------------------------------------------------------------
+ * Debug message
+ */
+//#define DEBUG							/* u-boot debug macro, nand, ethernet,... */
+
+#define CONFIG_VIP
+#define CONFIG_MLC_VIDEO
+#if defined(CONFIG_VIP)
+#if 0
+#define CONFIG_VIP_LU_ADDR          0x7FEF2000
+#define CONFIG_VIP_CB_ADDR          0x7FF62800
+#define CONFIG_VIP_CR_ADDR          0x7FF79000
+#else
+#define CONFIG_VIP_LU_ADDR          0x7FD28000
+#define CONFIG_VIP_CB_ADDR          0x7FD98800
+#define CONFIG_VIP_CR_ADDR          0x7FDAF000
+#endif
+#endif
+#endif /* __CONFIG_H__ */
+
